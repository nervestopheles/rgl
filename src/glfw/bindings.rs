/* automatically generated by rust-bindgen 0.60.1 */

pub const GLFW_VERSION_MAJOR: u32 = 3;
pub const GLFW_VERSION_MINOR: u32 = 2;
pub const GLFW_VERSION_REVISION: u32 = 1;
pub const GLFW_TRUE: u32 = 1;
pub const GLFW_FALSE: u32 = 0;
pub const GLFW_RELEASE: u32 = 0;
pub const GLFW_PRESS: u32 = 1;
pub const GLFW_REPEAT: u32 = 2;
pub const GLFW_KEY_UNKNOWN: i32 = -1;
pub const GLFW_KEY_SPACE: u32 = 32;
pub const GLFW_KEY_APOSTROPHE: u32 = 39;
pub const GLFW_KEY_COMMA: u32 = 44;
pub const GLFW_KEY_MINUS: u32 = 45;
pub const GLFW_KEY_PERIOD: u32 = 46;
pub const GLFW_KEY_SLASH: u32 = 47;
pub const GLFW_KEY_0: u32 = 48;
pub const GLFW_KEY_1: u32 = 49;
pub const GLFW_KEY_2: u32 = 50;
pub const GLFW_KEY_3: u32 = 51;
pub const GLFW_KEY_4: u32 = 52;
pub const GLFW_KEY_5: u32 = 53;
pub const GLFW_KEY_6: u32 = 54;
pub const GLFW_KEY_7: u32 = 55;
pub const GLFW_KEY_8: u32 = 56;
pub const GLFW_KEY_9: u32 = 57;
pub const GLFW_KEY_SEMICOLON: u32 = 59;
pub const GLFW_KEY_EQUAL: u32 = 61;
pub const GLFW_KEY_A: u32 = 65;
pub const GLFW_KEY_B: u32 = 66;
pub const GLFW_KEY_C: u32 = 67;
pub const GLFW_KEY_D: u32 = 68;
pub const GLFW_KEY_E: u32 = 69;
pub const GLFW_KEY_F: u32 = 70;
pub const GLFW_KEY_G: u32 = 71;
pub const GLFW_KEY_H: u32 = 72;
pub const GLFW_KEY_I: u32 = 73;
pub const GLFW_KEY_J: u32 = 74;
pub const GLFW_KEY_K: u32 = 75;
pub const GLFW_KEY_L: u32 = 76;
pub const GLFW_KEY_M: u32 = 77;
pub const GLFW_KEY_N: u32 = 78;
pub const GLFW_KEY_O: u32 = 79;
pub const GLFW_KEY_P: u32 = 80;
pub const GLFW_KEY_Q: u32 = 81;
pub const GLFW_KEY_R: u32 = 82;
pub const GLFW_KEY_S: u32 = 83;
pub const GLFW_KEY_T: u32 = 84;
pub const GLFW_KEY_U: u32 = 85;
pub const GLFW_KEY_V: u32 = 86;
pub const GLFW_KEY_W: u32 = 87;
pub const GLFW_KEY_X: u32 = 88;
pub const GLFW_KEY_Y: u32 = 89;
pub const GLFW_KEY_Z: u32 = 90;
pub const GLFW_KEY_LEFT_BRACKET: u32 = 91;
pub const GLFW_KEY_BACKSLASH: u32 = 92;
pub const GLFW_KEY_RIGHT_BRACKET: u32 = 93;
pub const GLFW_KEY_GRAVE_ACCENT: u32 = 96;
pub const GLFW_KEY_WORLD_1: u32 = 161;
pub const GLFW_KEY_WORLD_2: u32 = 162;
pub const GLFW_KEY_ESCAPE: u32 = 256;
pub const GLFW_KEY_ENTER: u32 = 257;
pub const GLFW_KEY_TAB: u32 = 258;
pub const GLFW_KEY_BACKSPACE: u32 = 259;
pub const GLFW_KEY_INSERT: u32 = 260;
pub const GLFW_KEY_DELETE: u32 = 261;
pub const GLFW_KEY_RIGHT: u32 = 262;
pub const GLFW_KEY_LEFT: u32 = 263;
pub const GLFW_KEY_DOWN: u32 = 264;
pub const GLFW_KEY_UP: u32 = 265;
pub const GLFW_KEY_PAGE_UP: u32 = 266;
pub const GLFW_KEY_PAGE_DOWN: u32 = 267;
pub const GLFW_KEY_HOME: u32 = 268;
pub const GLFW_KEY_END: u32 = 269;
pub const GLFW_KEY_CAPS_LOCK: u32 = 280;
pub const GLFW_KEY_SCROLL_LOCK: u32 = 281;
pub const GLFW_KEY_NUM_LOCK: u32 = 282;
pub const GLFW_KEY_PRINT_SCREEN: u32 = 283;
pub const GLFW_KEY_PAUSE: u32 = 284;
pub const GLFW_KEY_F1: u32 = 290;
pub const GLFW_KEY_F2: u32 = 291;
pub const GLFW_KEY_F3: u32 = 292;
pub const GLFW_KEY_F4: u32 = 293;
pub const GLFW_KEY_F5: u32 = 294;
pub const GLFW_KEY_F6: u32 = 295;
pub const GLFW_KEY_F7: u32 = 296;
pub const GLFW_KEY_F8: u32 = 297;
pub const GLFW_KEY_F9: u32 = 298;
pub const GLFW_KEY_F10: u32 = 299;
pub const GLFW_KEY_F11: u32 = 300;
pub const GLFW_KEY_F12: u32 = 301;
pub const GLFW_KEY_F13: u32 = 302;
pub const GLFW_KEY_F14: u32 = 303;
pub const GLFW_KEY_F15: u32 = 304;
pub const GLFW_KEY_F16: u32 = 305;
pub const GLFW_KEY_F17: u32 = 306;
pub const GLFW_KEY_F18: u32 = 307;
pub const GLFW_KEY_F19: u32 = 308;
pub const GLFW_KEY_F20: u32 = 309;
pub const GLFW_KEY_F21: u32 = 310;
pub const GLFW_KEY_F22: u32 = 311;
pub const GLFW_KEY_F23: u32 = 312;
pub const GLFW_KEY_F24: u32 = 313;
pub const GLFW_KEY_F25: u32 = 314;
pub const GLFW_KEY_KP_0: u32 = 320;
pub const GLFW_KEY_KP_1: u32 = 321;
pub const GLFW_KEY_KP_2: u32 = 322;
pub const GLFW_KEY_KP_3: u32 = 323;
pub const GLFW_KEY_KP_4: u32 = 324;
pub const GLFW_KEY_KP_5: u32 = 325;
pub const GLFW_KEY_KP_6: u32 = 326;
pub const GLFW_KEY_KP_7: u32 = 327;
pub const GLFW_KEY_KP_8: u32 = 328;
pub const GLFW_KEY_KP_9: u32 = 329;
pub const GLFW_KEY_KP_DECIMAL: u32 = 330;
pub const GLFW_KEY_KP_DIVIDE: u32 = 331;
pub const GLFW_KEY_KP_MULTIPLY: u32 = 332;
pub const GLFW_KEY_KP_SUBTRACT: u32 = 333;
pub const GLFW_KEY_KP_ADD: u32 = 334;
pub const GLFW_KEY_KP_ENTER: u32 = 335;
pub const GLFW_KEY_KP_EQUAL: u32 = 336;
pub const GLFW_KEY_LEFT_SHIFT: u32 = 340;
pub const GLFW_KEY_LEFT_CONTROL: u32 = 341;
pub const GLFW_KEY_LEFT_ALT: u32 = 342;
pub const GLFW_KEY_LEFT_SUPER: u32 = 343;
pub const GLFW_KEY_RIGHT_SHIFT: u32 = 344;
pub const GLFW_KEY_RIGHT_CONTROL: u32 = 345;
pub const GLFW_KEY_RIGHT_ALT: u32 = 346;
pub const GLFW_KEY_RIGHT_SUPER: u32 = 347;
pub const GLFW_KEY_MENU: u32 = 348;
pub const GLFW_KEY_LAST: u32 = 348;
pub const GLFW_MOD_SHIFT: u32 = 1;
pub const GLFW_MOD_CONTROL: u32 = 2;
pub const GLFW_MOD_ALT: u32 = 4;
pub const GLFW_MOD_SUPER: u32 = 8;
pub const GLFW_MOUSE_BUTTON_1: u32 = 0;
pub const GLFW_MOUSE_BUTTON_2: u32 = 1;
pub const GLFW_MOUSE_BUTTON_3: u32 = 2;
pub const GLFW_MOUSE_BUTTON_4: u32 = 3;
pub const GLFW_MOUSE_BUTTON_5: u32 = 4;
pub const GLFW_MOUSE_BUTTON_6: u32 = 5;
pub const GLFW_MOUSE_BUTTON_7: u32 = 6;
pub const GLFW_MOUSE_BUTTON_8: u32 = 7;
pub const GLFW_MOUSE_BUTTON_LAST: u32 = 7;
pub const GLFW_MOUSE_BUTTON_LEFT: u32 = 0;
pub const GLFW_MOUSE_BUTTON_RIGHT: u32 = 1;
pub const GLFW_MOUSE_BUTTON_MIDDLE: u32 = 2;
pub const GLFW_JOYSTICK_1: u32 = 0;
pub const GLFW_JOYSTICK_2: u32 = 1;
pub const GLFW_JOYSTICK_3: u32 = 2;
pub const GLFW_JOYSTICK_4: u32 = 3;
pub const GLFW_JOYSTICK_5: u32 = 4;
pub const GLFW_JOYSTICK_6: u32 = 5;
pub const GLFW_JOYSTICK_7: u32 = 6;
pub const GLFW_JOYSTICK_8: u32 = 7;
pub const GLFW_JOYSTICK_9: u32 = 8;
pub const GLFW_JOYSTICK_10: u32 = 9;
pub const GLFW_JOYSTICK_11: u32 = 10;
pub const GLFW_JOYSTICK_12: u32 = 11;
pub const GLFW_JOYSTICK_13: u32 = 12;
pub const GLFW_JOYSTICK_14: u32 = 13;
pub const GLFW_JOYSTICK_15: u32 = 14;
pub const GLFW_JOYSTICK_16: u32 = 15;
pub const GLFW_JOYSTICK_LAST: u32 = 15;
pub const GLFW_NOT_INITIALIZED: u32 = 65537;
pub const GLFW_NO_CURRENT_CONTEXT: u32 = 65538;
pub const GLFW_INVALID_ENUM: u32 = 65539;
pub const GLFW_INVALID_VALUE: u32 = 65540;
pub const GLFW_OUT_OF_MEMORY: u32 = 65541;
pub const GLFW_API_UNAVAILABLE: u32 = 65542;
pub const GLFW_VERSION_UNAVAILABLE: u32 = 65543;
pub const GLFW_PLATFORM_ERROR: u32 = 65544;
pub const GLFW_FORMAT_UNAVAILABLE: u32 = 65545;
pub const GLFW_NO_WINDOW_CONTEXT: u32 = 65546;
pub const GLFW_FOCUSED: u32 = 131073;
pub const GLFW_ICONIFIED: u32 = 131074;
pub const GLFW_RESIZABLE: u32 = 131075;
pub const GLFW_VISIBLE: u32 = 131076;
pub const GLFW_DECORATED: u32 = 131077;
pub const GLFW_AUTO_ICONIFY: u32 = 131078;
pub const GLFW_FLOATING: u32 = 131079;
pub const GLFW_MAXIMIZED: u32 = 131080;
pub const GLFW_RED_BITS: u32 = 135169;
pub const GLFW_GREEN_BITS: u32 = 135170;
pub const GLFW_BLUE_BITS: u32 = 135171;
pub const GLFW_ALPHA_BITS: u32 = 135172;
pub const GLFW_DEPTH_BITS: u32 = 135173;
pub const GLFW_STENCIL_BITS: u32 = 135174;
pub const GLFW_ACCUM_RED_BITS: u32 = 135175;
pub const GLFW_ACCUM_GREEN_BITS: u32 = 135176;
pub const GLFW_ACCUM_BLUE_BITS: u32 = 135177;
pub const GLFW_ACCUM_ALPHA_BITS: u32 = 135178;
pub const GLFW_AUX_BUFFERS: u32 = 135179;
pub const GLFW_STEREO: u32 = 135180;
pub const GLFW_SAMPLES: u32 = 135181;
pub const GLFW_SRGB_CAPABLE: u32 = 135182;
pub const GLFW_REFRESH_RATE: u32 = 135183;
pub const GLFW_DOUBLEBUFFER: u32 = 135184;
pub const GLFW_CLIENT_API: u32 = 139265;
pub const GLFW_CONTEXT_VERSION_MAJOR: u32 = 139266;
pub const GLFW_CONTEXT_VERSION_MINOR: u32 = 139267;
pub const GLFW_CONTEXT_REVISION: u32 = 139268;
pub const GLFW_CONTEXT_ROBUSTNESS: u32 = 139269;
pub const GLFW_OPENGL_FORWARD_COMPAT: u32 = 139270;
pub const GLFW_OPENGL_DEBUG_CONTEXT: u32 = 139271;
pub const GLFW_OPENGL_PROFILE: u32 = 139272;
pub const GLFW_CONTEXT_RELEASE_BEHAVIOR: u32 = 139273;
pub const GLFW_CONTEXT_NO_ERROR: u32 = 139274;
pub const GLFW_CONTEXT_CREATION_API: u32 = 139275;
pub const GLFW_NO_API: u32 = 0;
pub const GLFW_OPENGL_API: u32 = 196609;
pub const GLFW_OPENGL_ES_API: u32 = 196610;
pub const GLFW_NO_ROBUSTNESS: u32 = 0;
pub const GLFW_NO_RESET_NOTIFICATION: u32 = 200705;
pub const GLFW_LOSE_CONTEXT_ON_RESET: u32 = 200706;
pub const GLFW_OPENGL_ANY_PROFILE: u32 = 0;
pub const GLFW_OPENGL_CORE_PROFILE: u32 = 204801;
pub const GLFW_OPENGL_COMPAT_PROFILE: u32 = 204802;
pub const GLFW_CURSOR: u32 = 208897;
pub const GLFW_STICKY_KEYS: u32 = 208898;
pub const GLFW_STICKY_MOUSE_BUTTONS: u32 = 208899;
pub const GLFW_CURSOR_NORMAL: u32 = 212993;
pub const GLFW_CURSOR_HIDDEN: u32 = 212994;
pub const GLFW_CURSOR_DISABLED: u32 = 212995;
pub const GLFW_ANY_RELEASE_BEHAVIOR: u32 = 0;
pub const GLFW_RELEASE_BEHAVIOR_FLUSH: u32 = 217089;
pub const GLFW_RELEASE_BEHAVIOR_NONE: u32 = 217090;
pub const GLFW_NATIVE_CONTEXT_API: u32 = 221185;
pub const GLFW_EGL_CONTEXT_API: u32 = 221186;
pub const GLFW_ARROW_CURSOR: u32 = 221185;
pub const GLFW_IBEAM_CURSOR: u32 = 221186;
pub const GLFW_CROSSHAIR_CURSOR: u32 = 221187;
pub const GLFW_HAND_CURSOR: u32 = 221188;
pub const GLFW_HRESIZE_CURSOR: u32 = 221189;
pub const GLFW_VRESIZE_CURSOR: u32 = 221190;
pub const GLFW_CONNECTED: u32 = 262145;
pub const GLFW_DISCONNECTED: u32 = 262146;
pub const GLFW_DONT_CARE: i32 = -1;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[doc = " @brief Client API function pointer type."]
#[doc = ""]
#[doc = "  Generic function pointer used for returning client API function pointers"]
#[doc = "  without forcing a cast from a regular pointer."]
#[doc = ""]
#[doc = "  @sa @ref context_glext"]
#[doc = "  @sa glfwGetProcAddress"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup context"]
pub type GLFWglproc = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " @brief Vulkan API function pointer type."]
#[doc = ""]
#[doc = "  Generic function pointer used for returning Vulkan API function pointers"]
#[doc = "  without forcing a cast from a regular pointer."]
#[doc = ""]
#[doc = "  @sa @ref vulkan_proc"]
#[doc = "  @sa glfwGetInstanceProcAddress"]
#[doc = ""]
#[doc = "  @since Added in version 3.2."]
#[doc = ""]
#[doc = "  @ingroup vulkan"]
pub type GLFWvkproc = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWmonitor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWwindow {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWcursor {
    _unused: [u8; 0],
}
#[doc = " @brief The function signature for error callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for error callback functions."]
#[doc = ""]
#[doc = "  @param[in] error An [error code](@ref errors)."]
#[doc = "  @param[in] description A UTF-8 encoded string describing the error."]
#[doc = ""]
#[doc = "  @sa @ref error_handling"]
#[doc = "  @sa glfwSetErrorCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup init"]
pub type GLFWerrorfun = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char),
>;
#[doc = " @brief The function signature for window position callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for window position callback functions."]
#[doc = ""]
#[doc = "  @param[in] window The window that was moved."]
#[doc = "  @param[in] xpos The new x-coordinate, in screen coordinates, of the"]
#[doc = "  upper-left corner of the client area of the window."]
#[doc = "  @param[in] ypos The new y-coordinate, in screen coordinates, of the"]
#[doc = "  upper-left corner of the client area of the window."]
#[doc = ""]
#[doc = "  @sa @ref window_pos"]
#[doc = "  @sa glfwSetWindowPosCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWwindowposfun = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GLFWwindow,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ),
>;
#[doc = " @brief The function signature for window resize callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for window size callback functions."]
#[doc = ""]
#[doc = "  @param[in] window The window that was resized."]
#[doc = "  @param[in] width The new width, in screen coordinates, of the window."]
#[doc = "  @param[in] height The new height, in screen coordinates, of the window."]
#[doc = ""]
#[doc = "  @sa @ref window_size"]
#[doc = "  @sa glfwSetWindowSizeCallback"]
#[doc = ""]
#[doc = "  @since Added in version 1.0."]
#[doc = "  @glfw3 Added window handle parameter."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWwindowsizefun = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GLFWwindow,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ),
>;
#[doc = " @brief The function signature for window close callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for window close callback functions."]
#[doc = ""]
#[doc = "  @param[in] window The window that the user attempted to close."]
#[doc = ""]
#[doc = "  @sa @ref window_close"]
#[doc = "  @sa glfwSetWindowCloseCallback"]
#[doc = ""]
#[doc = "  @since Added in version 2.5."]
#[doc = "  @glfw3 Added window handle parameter."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWwindowclosefun = ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow)>;
#[doc = " @brief The function signature for window content refresh callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for window refresh callback functions."]
#[doc = ""]
#[doc = "  @param[in] window The window whose content needs to be refreshed."]
#[doc = ""]
#[doc = "  @sa @ref window_refresh"]
#[doc = "  @sa glfwSetWindowRefreshCallback"]
#[doc = ""]
#[doc = "  @since Added in version 2.5."]
#[doc = "  @glfw3 Added window handle parameter."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWwindowrefreshfun = ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow)>;
#[doc = " @brief The function signature for window focus/defocus callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for window focus callback functions."]
#[doc = ""]
#[doc = "  @param[in] window The window that gained or lost input focus."]
#[doc = "  @param[in] focused `GLFW_TRUE` if the window was given input focus, or"]
#[doc = "  `GLFW_FALSE` if it lost it."]
#[doc = ""]
#[doc = "  @sa @ref window_focus"]
#[doc = "  @sa glfwSetWindowFocusCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWwindowfocusfun =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow, arg2: ::std::os::raw::c_int)>;
#[doc = " @brief The function signature for window iconify/restore callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for window iconify/restore callback"]
#[doc = "  functions."]
#[doc = ""]
#[doc = "  @param[in] window The window that was iconified or restored."]
#[doc = "  @param[in] iconified `GLFW_TRUE` if the window was iconified, or"]
#[doc = "  `GLFW_FALSE` if it was restored."]
#[doc = ""]
#[doc = "  @sa @ref window_iconify"]
#[doc = "  @sa glfwSetWindowIconifyCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWwindowiconifyfun =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow, arg2: ::std::os::raw::c_int)>;
#[doc = " @brief The function signature for framebuffer resize callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for framebuffer resize callback"]
#[doc = "  functions."]
#[doc = ""]
#[doc = "  @param[in] window The window whose framebuffer was resized."]
#[doc = "  @param[in] width The new width, in pixels, of the framebuffer."]
#[doc = "  @param[in] height The new height, in pixels, of the framebuffer."]
#[doc = ""]
#[doc = "  @sa @ref window_fbsize"]
#[doc = "  @sa glfwSetFramebufferSizeCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWframebuffersizefun = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GLFWwindow,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ),
>;
#[doc = " @brief The function signature for mouse button callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for mouse button callback functions."]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] button The [mouse button](@ref buttons) that was pressed or"]
#[doc = "  released."]
#[doc = "  @param[in] action One of `GLFW_PRESS` or `GLFW_RELEASE`."]
#[doc = "  @param[in] mods Bit field describing which [modifier keys](@ref mods) were"]
#[doc = "  held down."]
#[doc = ""]
#[doc = "  @sa @ref input_mouse_button"]
#[doc = "  @sa glfwSetMouseButtonCallback"]
#[doc = ""]
#[doc = "  @since Added in version 1.0."]
#[doc = "  @glfw3 Added window handle and modifier mask parameters."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWmousebuttonfun = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GLFWwindow,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ),
>;
#[doc = " @brief The function signature for cursor position callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for cursor position callback functions."]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] xpos The new cursor x-coordinate, relative to the left edge of"]
#[doc = "  the client area."]
#[doc = "  @param[in] ypos The new cursor y-coordinate, relative to the top edge of the"]
#[doc = "  client area."]
#[doc = ""]
#[doc = "  @sa @ref cursor_pos"]
#[doc = "  @sa glfwSetCursorPosCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0.  Replaces `GLFWmouseposfun`."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWcursorposfun =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow, arg2: f64, arg3: f64)>;
#[doc = " @brief The function signature for cursor enter/leave callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for cursor enter/leave callback functions."]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] entered `GLFW_TRUE` if the cursor entered the window's client"]
#[doc = "  area, or `GLFW_FALSE` if it left it."]
#[doc = ""]
#[doc = "  @sa @ref cursor_enter"]
#[doc = "  @sa glfwSetCursorEnterCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWcursorenterfun =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow, arg2: ::std::os::raw::c_int)>;
#[doc = " @brief The function signature for scroll callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for scroll callback functions."]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] xoffset The scroll offset along the x-axis."]
#[doc = "  @param[in] yoffset The scroll offset along the y-axis."]
#[doc = ""]
#[doc = "  @sa @ref scrolling"]
#[doc = "  @sa glfwSetScrollCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0.  Replaces `GLFWmousewheelfun`."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWscrollfun =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow, arg2: f64, arg3: f64)>;
#[doc = " @brief The function signature for keyboard key callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for keyboard key callback functions."]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] key The [keyboard key](@ref keys) that was pressed or released."]
#[doc = "  @param[in] scancode The system-specific scancode of the key."]
#[doc = "  @param[in] action `GLFW_PRESS`, `GLFW_RELEASE` or `GLFW_REPEAT`."]
#[doc = "  @param[in] mods Bit field describing which [modifier keys](@ref mods) were"]
#[doc = "  held down."]
#[doc = ""]
#[doc = "  @sa @ref input_key"]
#[doc = "  @sa glfwSetKeyCallback"]
#[doc = ""]
#[doc = "  @since Added in version 1.0."]
#[doc = "  @glfw3 Added window handle, scancode and modifier mask parameters."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWkeyfun = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GLFWwindow,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ),
>;
#[doc = " @brief The function signature for Unicode character callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for Unicode character callback functions."]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] codepoint The Unicode code point of the character."]
#[doc = ""]
#[doc = "  @sa @ref input_char"]
#[doc = "  @sa glfwSetCharCallback"]
#[doc = ""]
#[doc = "  @since Added in version 2.4."]
#[doc = "  @glfw3 Added window handle parameter."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWcharfun = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut GLFWwindow, arg2: ::std::os::raw::c_uint),
>;
#[doc = " @brief The function signature for Unicode character with modifiers"]
#[doc = "  callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for Unicode character with modifiers callback"]
#[doc = "  functions.  It is called for each input character, regardless of what"]
#[doc = "  modifier keys are held down."]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] codepoint The Unicode code point of the character."]
#[doc = "  @param[in] mods Bit field describing which [modifier keys](@ref mods) were"]
#[doc = "  held down."]
#[doc = ""]
#[doc = "  @sa @ref input_char"]
#[doc = "  @sa glfwSetCharModsCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.1."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWcharmodsfun = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GLFWwindow,
        arg2: ::std::os::raw::c_uint,
        arg3: ::std::os::raw::c_int,
    ),
>;
#[doc = " @brief The function signature for file drop callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for file drop callbacks."]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] count The number of dropped files."]
#[doc = "  @param[in] paths The UTF-8 encoded file and/or directory path names."]
#[doc = ""]
#[doc = "  @sa @ref path_drop"]
#[doc = "  @sa glfwSetDropCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.1."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWdropfun = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GLFWwindow,
        arg2: ::std::os::raw::c_int,
        arg3: *mut *const ::std::os::raw::c_char,
    ),
>;
#[doc = " @brief The function signature for monitor configuration callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for monitor configuration callback functions."]
#[doc = ""]
#[doc = "  @param[in] monitor The monitor that was connected or disconnected."]
#[doc = "  @param[in] event One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`."]
#[doc = ""]
#[doc = "  @sa @ref monitor_event"]
#[doc = "  @sa glfwSetMonitorCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup monitor"]
pub type GLFWmonitorfun = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut GLFWmonitor, arg2: ::std::os::raw::c_int),
>;
#[doc = " @brief The function signature for joystick configuration callbacks."]
#[doc = ""]
#[doc = "  This is the function signature for joystick configuration callback"]
#[doc = "  functions."]
#[doc = ""]
#[doc = "  @param[in] joy The joystick that was connected or disconnected."]
#[doc = "  @param[in] event One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`."]
#[doc = ""]
#[doc = "  @sa @ref joystick_event"]
#[doc = "  @sa glfwSetJoystickCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.2."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWjoystickfun = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int),
>;
#[doc = " @brief Video mode type."]
#[doc = ""]
#[doc = "  This describes a single video mode."]
#[doc = ""]
#[doc = "  @sa @ref monitor_modes"]
#[doc = "  @sa glfwGetVideoMode glfwGetVideoModes"]
#[doc = ""]
#[doc = "  @since Added in version 1.0."]
#[doc = "  @glfw3 Added refresh rate member."]
#[doc = ""]
#[doc = "  @ingroup monitor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWvidmode {
    #[doc = " The width, in screen coordinates, of the video mode."]
    pub width: ::std::os::raw::c_int,
    #[doc = " The height, in screen coordinates, of the video mode."]
    pub height: ::std::os::raw::c_int,
    #[doc = " The bit depth of the red channel of the video mode."]
    pub redBits: ::std::os::raw::c_int,
    #[doc = " The bit depth of the green channel of the video mode."]
    pub greenBits: ::std::os::raw::c_int,
    #[doc = " The bit depth of the blue channel of the video mode."]
    pub blueBits: ::std::os::raw::c_int,
    #[doc = " The refresh rate, in Hz, of the video mode."]
    pub refreshRate: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GLFWvidmode() {
    assert_eq!(
        ::std::mem::size_of::<GLFWvidmode>(),
        24usize,
        concat!("Size of: ", stringify!(GLFWvidmode))
    );
    assert_eq!(
        ::std::mem::align_of::<GLFWvidmode>(),
        4usize,
        concat!("Alignment of ", stringify!(GLFWvidmode))
    );
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GLFWvidmode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(GLFWvidmode),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GLFWvidmode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(GLFWvidmode),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_redBits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GLFWvidmode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).redBits) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(GLFWvidmode),
                "::",
                stringify!(redBits)
            )
        );
    }
    test_field_redBits();
    fn test_field_greenBits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GLFWvidmode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).greenBits) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(GLFWvidmode),
                "::",
                stringify!(greenBits)
            )
        );
    }
    test_field_greenBits();
    fn test_field_blueBits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GLFWvidmode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blueBits) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(GLFWvidmode),
                "::",
                stringify!(blueBits)
            )
        );
    }
    test_field_blueBits();
    fn test_field_refreshRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GLFWvidmode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).refreshRate) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(GLFWvidmode),
                "::",
                stringify!(refreshRate)
            )
        );
    }
    test_field_refreshRate();
}
#[doc = " @brief Gamma ramp."]
#[doc = ""]
#[doc = "  This describes the gamma ramp for a monitor."]
#[doc = ""]
#[doc = "  @sa @ref monitor_gamma"]
#[doc = "  @sa glfwGetGammaRamp glfwSetGammaRamp"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup monitor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWgammaramp {
    #[doc = " An array of value describing the response of the red channel."]
    pub red: *mut ::std::os::raw::c_ushort,
    #[doc = " An array of value describing the response of the green channel."]
    pub green: *mut ::std::os::raw::c_ushort,
    #[doc = " An array of value describing the response of the blue channel."]
    pub blue: *mut ::std::os::raw::c_ushort,
    #[doc = " The number of elements in each array."]
    pub size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_GLFWgammaramp() {
    assert_eq!(
        ::std::mem::size_of::<GLFWgammaramp>(),
        32usize,
        concat!("Size of: ", stringify!(GLFWgammaramp))
    );
    assert_eq!(
        ::std::mem::align_of::<GLFWgammaramp>(),
        8usize,
        concat!("Alignment of ", stringify!(GLFWgammaramp))
    );
    fn test_field_red() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GLFWgammaramp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(GLFWgammaramp),
                "::",
                stringify!(red)
            )
        );
    }
    test_field_red();
    fn test_field_green() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GLFWgammaramp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(GLFWgammaramp),
                "::",
                stringify!(green)
            )
        );
    }
    test_field_green();
    fn test_field_blue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GLFWgammaramp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(GLFWgammaramp),
                "::",
                stringify!(blue)
            )
        );
    }
    test_field_blue();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GLFWgammaramp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(GLFWgammaramp),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
#[doc = " @brief Image data."]
#[doc = ""]
#[doc = "  @sa @ref cursor_custom"]
#[doc = "  @sa @ref window_icon"]
#[doc = ""]
#[doc = "  @since Added in version 2.1."]
#[doc = "  @glfw3 Removed format and bytes-per-pixel members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWimage {
    #[doc = " The width, in pixels, of this image."]
    pub width: ::std::os::raw::c_int,
    #[doc = " The height, in pixels, of this image."]
    pub height: ::std::os::raw::c_int,
    #[doc = " The pixel data of this image, arranged left-to-right, top-to-bottom."]
    pub pixels: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_GLFWimage() {
    assert_eq!(
        ::std::mem::size_of::<GLFWimage>(),
        16usize,
        concat!("Size of: ", stringify!(GLFWimage))
    );
    assert_eq!(
        ::std::mem::align_of::<GLFWimage>(),
        8usize,
        concat!("Alignment of ", stringify!(GLFWimage))
    );
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GLFWimage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(GLFWimage),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GLFWimage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(GLFWimage),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_pixels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<GLFWimage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixels) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(GLFWimage),
                "::",
                stringify!(pixels)
            )
        );
    }
    test_field_pixels();
}
extern "C" {
    #[doc = " @brief Initializes the GLFW library."]
    #[doc = ""]
    #[doc = "  This function initializes the GLFW library.  Before most GLFW functions can"]
    #[doc = "  be used, GLFW must be initialized, and before an application terminates GLFW"]
    #[doc = "  should be terminated in order to free any resources allocated during or"]
    #[doc = "  after initialization."]
    #[doc = ""]
    #[doc = "  If this function fails, it calls @ref glfwTerminate before returning.  If it"]
    #[doc = "  succeeds, you should call @ref glfwTerminate before the application exits."]
    #[doc = ""]
    #[doc = "  Additional calls to this function after successful initialization but before"]
    #[doc = "  termination will return `GLFW_TRUE` immediately."]
    #[doc = ""]
    #[doc = "  @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark @osx This function will change the current directory of the"]
    #[doc = "  application to the `Contents/Resources` subdirectory of the application's"]
    #[doc = "  bundle, if present.  This can be disabled with a"]
    #[doc = "  [compile-time option](@ref compile_options_osx)."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref intro_init"]
    #[doc = "  @sa glfwTerminate"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup init"]
    pub fn glfwInit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Terminates the GLFW library."]
    #[doc = ""]
    #[doc = "  This function destroys all remaining windows and cursors, restores any"]
    #[doc = "  modified gamma ramps and frees any other allocated resources.  Once this"]
    #[doc = "  function is called, you must again call @ref glfwInit successfully before"]
    #[doc = "  you will be able to use most GLFW functions."]
    #[doc = ""]
    #[doc = "  If GLFW has been successfully initialized, this function should be called"]
    #[doc = "  before the application exits.  If initialization fails, there is no need to"]
    #[doc = "  call this function, as it is called by @ref glfwInit before it returns"]
    #[doc = "  failure."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark This function may be called before @ref glfwInit."]
    #[doc = ""]
    #[doc = "  @warning The contexts of any remaining windows must not be current on any"]
    #[doc = "  other thread when this function is called."]
    #[doc = ""]
    #[doc = "  @reentrancy This function must not be called from a callback."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref intro_init"]
    #[doc = "  @sa glfwInit"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup init"]
    pub fn glfwTerminate();
}
extern "C" {
    #[doc = " @brief Retrieves the version of the GLFW library."]
    #[doc = ""]
    #[doc = "  This function retrieves the major, minor and revision numbers of the GLFW"]
    #[doc = "  library.  It is intended for when you are using GLFW as a shared library and"]
    #[doc = "  want to ensure that you are using the minimum required version."]
    #[doc = ""]
    #[doc = "  Any or all of the version arguments may be `NULL`."]
    #[doc = ""]
    #[doc = "  @param[out] major Where to store the major version number, or `NULL`."]
    #[doc = "  @param[out] minor Where to store the minor version number, or `NULL`."]
    #[doc = "  @param[out] rev Where to store the revision number, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors None."]
    #[doc = ""]
    #[doc = "  @remark This function may be called before @ref glfwInit."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref intro_version"]
    #[doc = "  @sa glfwGetVersionString"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup init"]
    pub fn glfwGetVersion(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        rev: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Returns a string describing the compile-time configuration."]
    #[doc = ""]
    #[doc = "  This function returns the compile-time generated"]
    #[doc = "  [version string](@ref intro_version_string) of the GLFW library binary.  It"]
    #[doc = "  describes the version, platform, compiler and any platform-specific"]
    #[doc = "  compile-time options.  It should not be confused with the OpenGL or OpenGL"]
    #[doc = "  ES version string, queried with `glGetString`."]
    #[doc = ""]
    #[doc = "  __Do not use the version string__ to parse the GLFW library version.  The"]
    #[doc = "  @ref glfwGetVersion function provides the version of the running library"]
    #[doc = "  binary in numerical format."]
    #[doc = ""]
    #[doc = "  @return The ASCII encoded GLFW version string."]
    #[doc = ""]
    #[doc = "  @errors None."]
    #[doc = ""]
    #[doc = "  @remark This function may be called before @ref glfwInit."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned string is static and compile-time generated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref intro_version"]
    #[doc = "  @sa glfwGetVersion"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup init"]
    pub fn glfwGetVersionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Sets the error callback."]
    #[doc = ""]
    #[doc = "  This function sets the error callback, which is called with an error code"]
    #[doc = "  and a human-readable description each time a GLFW error occurs."]
    #[doc = ""]
    #[doc = "  The error callback is called on the thread where the error occurred.  If you"]
    #[doc = "  are using GLFW from multiple threads, your error callback needs to be"]
    #[doc = "  written accordingly."]
    #[doc = ""]
    #[doc = "  Because the description string may have been generated specifically for that"]
    #[doc = "  error, it is not guaranteed to be valid after the callback has returned.  If"]
    #[doc = "  you wish to use it after the callback returns, you need to make a copy."]
    #[doc = ""]
    #[doc = "  Once set, the error callback remains set even after the library has been"]
    #[doc = "  terminated."]
    #[doc = ""]
    #[doc = "  @param[in] cbfun The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set."]
    #[doc = ""]
    #[doc = "  @errors None."]
    #[doc = ""]
    #[doc = "  @remark This function may be called before @ref glfwInit."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref error_handling"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup init"]
    pub fn glfwSetErrorCallback(cbfun: GLFWerrorfun) -> GLFWerrorfun;
}
extern "C" {
    #[doc = " @brief Returns the currently connected monitors."]
    #[doc = ""]
    #[doc = "  This function returns an array of handles for all currently connected"]
    #[doc = "  monitors.  The primary monitor is always first in the returned array.  If no"]
    #[doc = "  monitors were found, this function returns `NULL`."]
    #[doc = ""]
    #[doc = "  @param[out] count Where to store the number of monitors in the returned"]
    #[doc = "  array.  This is set to zero if an error occurred."]
    #[doc = "  @return An array of monitor handles, or `NULL` if no monitors were found or"]
    #[doc = "  if an [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned array is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is guaranteed to be valid only until the"]
    #[doc = "  monitor configuration changes or the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_monitors"]
    #[doc = "  @sa @ref monitor_event"]
    #[doc = "  @sa glfwGetPrimaryMonitor"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetMonitors(count: *mut ::std::os::raw::c_int) -> *mut *mut GLFWmonitor;
}
extern "C" {
    #[doc = " @brief Returns the primary monitor."]
    #[doc = ""]
    #[doc = "  This function returns the primary monitor.  This is usually the monitor"]
    #[doc = "  where elements like the task bar or global menu bar are located."]
    #[doc = ""]
    #[doc = "  @return The primary monitor, or `NULL` if no monitors were found or if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @remark The primary monitor is always first in the array returned by @ref"]
    #[doc = "  glfwGetMonitors."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_monitors"]
    #[doc = "  @sa glfwGetMonitors"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetPrimaryMonitor() -> *mut GLFWmonitor;
}
extern "C" {
    #[doc = " @brief Returns the position of the monitor's viewport on the virtual screen."]
    #[doc = ""]
    #[doc = "  This function returns the position, in screen coordinates, of the upper-left"]
    #[doc = "  corner of the specified monitor."]
    #[doc = ""]
    #[doc = "  Any or all of the position arguments may be `NULL`.  If an error occurs, all"]
    #[doc = "  non-`NULL` position arguments will be set to zero."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor to query."]
    #[doc = "  @param[out] xpos Where to store the monitor x-coordinate, or `NULL`."]
    #[doc = "  @param[out] ypos Where to store the monitor y-coordinate, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_properties"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetMonitorPos(
        monitor: *mut GLFWmonitor,
        xpos: *mut ::std::os::raw::c_int,
        ypos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Returns the physical size of the monitor."]
    #[doc = ""]
    #[doc = "  This function returns the size, in millimetres, of the display area of the"]
    #[doc = "  specified monitor."]
    #[doc = ""]
    #[doc = "  Some systems do not provide accurate monitor size information, either"]
    #[doc = "  because the monitor"]
    #[doc = "  [EDID](https://en.wikipedia.org/wiki/Extended_display_identification_data)"]
    #[doc = "  data is incorrect or because the driver does not report it accurately."]
    #[doc = ""]
    #[doc = "  Any or all of the size arguments may be `NULL`.  If an error occurs, all"]
    #[doc = "  non-`NULL` size arguments will be set to zero."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor to query."]
    #[doc = "  @param[out] widthMM Where to store the width, in millimetres, of the"]
    #[doc = "  monitor's display area, or `NULL`."]
    #[doc = "  @param[out] heightMM Where to store the height, in millimetres, of the"]
    #[doc = "  monitor's display area, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @remark @win32 calculates the returned physical size from the"]
    #[doc = "  current resolution and system DPI instead of querying the monitor EDID data."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_properties"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetMonitorPhysicalSize(
        monitor: *mut GLFWmonitor,
        widthMM: *mut ::std::os::raw::c_int,
        heightMM: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Returns the name of the specified monitor."]
    #[doc = ""]
    #[doc = "  This function returns a human-readable name, encoded as UTF-8, of the"]
    #[doc = "  specified monitor.  The name typically reflects the make and model of the"]
    #[doc = "  monitor and is not guaranteed to be unique among the connected monitors."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor to query."]
    #[doc = "  @return The UTF-8 encoded name of the monitor, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned string is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the specified monitor is"]
    #[doc = "  disconnected or the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_properties"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetMonitorName(monitor: *mut GLFWmonitor) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Sets the monitor configuration callback."]
    #[doc = ""]
    #[doc = "  This function sets the monitor configuration callback, or removes the"]
    #[doc = "  currently set callback.  This is called when a monitor is connected to or"]
    #[doc = "  disconnected from the system."]
    #[doc = ""]
    #[doc = "  @param[in] cbfun The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_event"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwSetMonitorCallback(cbfun: GLFWmonitorfun) -> GLFWmonitorfun;
}
extern "C" {
    #[doc = " @brief Returns the available video modes for the specified monitor."]
    #[doc = ""]
    #[doc = "  This function returns an array of all video modes supported by the specified"]
    #[doc = "  monitor.  The returned array is sorted in ascending order, first by color"]
    #[doc = "  bit depth (the sum of all channel depths) and then by resolution area (the"]
    #[doc = "  product of width and height)."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor to query."]
    #[doc = "  @param[out] count Where to store the number of video modes in the returned"]
    #[doc = "  array.  This is set to zero if an error occurred."]
    #[doc = "  @return An array of video modes, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned array is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the specified monitor is"]
    #[doc = "  disconnected, this function is called again for that monitor or the library"]
    #[doc = "  is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_modes"]
    #[doc = "  @sa glfwGetVideoMode"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Changed to return an array of modes for a specific monitor."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetVideoModes(
        monitor: *mut GLFWmonitor,
        count: *mut ::std::os::raw::c_int,
    ) -> *const GLFWvidmode;
}
extern "C" {
    #[doc = " @brief Returns the current mode of the specified monitor."]
    #[doc = ""]
    #[doc = "  This function returns the current video mode of the specified monitor.  If"]
    #[doc = "  you have created a full screen window for that monitor, the return value"]
    #[doc = "  will depend on whether that window is iconified."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor to query."]
    #[doc = "  @return The current mode of the monitor, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned array is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the specified monitor is"]
    #[doc = "  disconnected or the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_modes"]
    #[doc = "  @sa glfwGetVideoModes"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwGetDesktopMode`."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetVideoMode(monitor: *mut GLFWmonitor) -> *const GLFWvidmode;
}
extern "C" {
    #[doc = " @brief Generates a gamma ramp and sets it for the specified monitor."]
    #[doc = ""]
    #[doc = "  This function generates a 256-element gamma ramp from the specified exponent"]
    #[doc = "  and then calls @ref glfwSetGammaRamp with it.  The value must be a finite"]
    #[doc = "  number greater than zero."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor whose gamma ramp to set."]
    #[doc = "  @param[in] gamma The desired exponent."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_gamma"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwSetGamma(monitor: *mut GLFWmonitor, gamma: f32);
}
extern "C" {
    #[doc = " @brief Returns the current gamma ramp for the specified monitor."]
    #[doc = ""]
    #[doc = "  This function returns the current gamma ramp of the specified monitor."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor to query."]
    #[doc = "  @return The current gamma ramp, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned structure and its arrays are allocated and"]
    #[doc = "  freed by GLFW.  You should not free them yourself.  They are valid until the"]
    #[doc = "  specified monitor is disconnected, this function is called again for that"]
    #[doc = "  monitor or the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_gamma"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetGammaRamp(monitor: *mut GLFWmonitor) -> *const GLFWgammaramp;
}
extern "C" {
    #[doc = " @brief Sets the current gamma ramp for the specified monitor."]
    #[doc = ""]
    #[doc = "  This function sets the current gamma ramp for the specified monitor.  The"]
    #[doc = "  original gamma ramp for that monitor is saved by GLFW the first time this"]
    #[doc = "  function is called and is restored by @ref glfwTerminate."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor whose gamma ramp to set."]
    #[doc = "  @param[in] ramp The gamma ramp to use."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark Gamma ramp sizes other than 256 are not supported by all platforms"]
    #[doc = "  or graphics hardware."]
    #[doc = ""]
    #[doc = "  @remark @win32 The gamma ramp size must be 256."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The specified gamma ramp is copied before this function"]
    #[doc = "  returns."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_gamma"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwSetGammaRamp(monitor: *mut GLFWmonitor, ramp: *const GLFWgammaramp);
}
extern "C" {
    #[doc = " @brief Resets all window hints to their default values."]
    #[doc = ""]
    #[doc = "  This function resets all window hints to their"]
    #[doc = "  [default values](@ref window_hints_values)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_hints"]
    #[doc = "  @sa glfwWindowHint"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwDefaultWindowHints();
}
extern "C" {
    #[doc = " @brief Sets the specified window hint to the desired value."]
    #[doc = ""]
    #[doc = "  This function sets hints for the next call to @ref glfwCreateWindow.  The"]
    #[doc = "  hints, once set, retain their values until changed by a call to @ref"]
    #[doc = "  glfwWindowHint or @ref glfwDefaultWindowHints, or until the library is"]
    #[doc = "  terminated."]
    #[doc = ""]
    #[doc = "  This function does not check whether the specified hint values are valid."]
    #[doc = "  If you set hints to invalid values this will instead be reported by the next"]
    #[doc = "  call to @ref glfwCreateWindow."]
    #[doc = ""]
    #[doc = "  @param[in] hint The [window hint](@ref window_hints) to set."]
    #[doc = "  @param[in] value The new value of the window hint."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_INVALID_ENUM."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_hints"]
    #[doc = "  @sa glfwDefaultWindowHints"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwOpenWindowHint`."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwWindowHint(hint: ::std::os::raw::c_int, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Creates a window and its associated context."]
    #[doc = ""]
    #[doc = "  This function creates a window and its associated OpenGL or OpenGL ES"]
    #[doc = "  context.  Most of the options controlling how the window and its context"]
    #[doc = "  should be created are specified with [window hints](@ref window_hints)."]
    #[doc = ""]
    #[doc = "  Successful creation does not change which context is current.  Before you"]
    #[doc = "  can use the newly created context, you need to"]
    #[doc = "  [make it current](@ref context_current).  For information about the `share`"]
    #[doc = "  parameter, see @ref context_sharing."]
    #[doc = ""]
    #[doc = "  The created window, framebuffer and context may differ from what you"]
    #[doc = "  requested, as not all parameters and hints are"]
    #[doc = "  [hard constraints](@ref window_hints_hard).  This includes the size of the"]
    #[doc = "  window, especially for full screen windows.  To query the actual attributes"]
    #[doc = "  of the created window, framebuffer and context, see @ref"]
    #[doc = "  glfwGetWindowAttrib, @ref glfwGetWindowSize and @ref glfwGetFramebufferSize."]
    #[doc = ""]
    #[doc = "  To create a full screen window, you need to specify the monitor the window"]
    #[doc = "  will cover.  If no monitor is specified, the window will be windowed mode."]
    #[doc = "  Unless you have a way for the user to choose a specific monitor, it is"]
    #[doc = "  recommended that you pick the primary monitor.  For more information on how"]
    #[doc = "  to query connected monitors, see @ref monitor_monitors."]
    #[doc = ""]
    #[doc = "  For full screen windows, the specified size becomes the resolution of the"]
    #[doc = "  window's _desired video mode_.  As long as a full screen window is not"]
    #[doc = "  iconified, the supported video mode most closely matching the desired video"]
    #[doc = "  mode is set for the specified monitor.  For more information about full"]
    #[doc = "  screen windows, including the creation of so called _windowed full screen_"]
    #[doc = "  or _borderless full screen_ windows, see @ref window_windowed_full_screen."]
    #[doc = ""]
    #[doc = "  Once you have created the window, you can switch it between windowed and"]
    #[doc = "  full screen mode with @ref glfwSetWindowMonitor.  If the window has an"]
    #[doc = "  OpenGL or OpenGL ES context, it will be unaffected."]
    #[doc = ""]
    #[doc = "  By default, newly created windows use the placement recommended by the"]
    #[doc = "  window system.  To create the window at a specific position, make it"]
    #[doc = "  initially invisible using the [GLFW_VISIBLE](@ref window_hints_wnd) window"]
    #[doc = "  hint, set its [position](@ref window_pos) and then [show](@ref window_hide)"]
    #[doc = "  it."]
    #[doc = ""]
    #[doc = "  As long as at least one full screen window is not iconified, the screensaver"]
    #[doc = "  is prohibited from starting."]
    #[doc = ""]
    #[doc = "  Window systems put limits on window sizes.  Very large or very small window"]
    #[doc = "  dimensions may be overridden by the window system on creation.  Check the"]
    #[doc = "  actual [size](@ref window_size) after creation."]
    #[doc = ""]
    #[doc = "  The [swap interval](@ref buffer_swap) is not set during window creation and"]
    #[doc = "  the initial value may vary depending on driver settings and defaults."]
    #[doc = ""]
    #[doc = "  @param[in] width The desired width, in screen coordinates, of the window."]
    #[doc = "  This must be greater than zero."]
    #[doc = "  @param[in] height The desired height, in screen coordinates, of the window."]
    #[doc = "  This must be greater than zero."]
    #[doc = "  @param[in] title The initial, UTF-8 encoded window title."]
    #[doc = "  @param[in] monitor The monitor to use for full screen mode, or `NULL` for"]
    #[doc = "  windowed mode."]
    #[doc = "  @param[in] share The window whose context to share resources with, or `NULL`"]
    #[doc = "  to not share resources."]
    #[doc = "  @return The handle of the created window, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM, @ref GLFW_INVALID_VALUE, @ref GLFW_API_UNAVAILABLE, @ref"]
    #[doc = "  GLFW_VERSION_UNAVAILABLE, @ref GLFW_FORMAT_UNAVAILABLE and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark @win32 Window creation will fail if the Microsoft GDI software"]
    #[doc = "  OpenGL implementation is the only one available."]
    #[doc = ""]
    #[doc = "  @remark @win32 If the executable has an icon resource named `GLFW_ICON,` it"]
    #[doc = "  will be set as the initial icon for the window.  If no such icon is present,"]
    #[doc = "  the `IDI_WINLOGO` icon will be used instead.  To set a different icon, see"]
    #[doc = "  @ref glfwSetWindowIcon."]
    #[doc = ""]
    #[doc = "  @remark @win32 The context to share resources with must not be current on"]
    #[doc = "  any other thread."]
    #[doc = ""]
    #[doc = "  @remark @osx The GLFW window has no icon, as it is not a document"]
    #[doc = "  window, but the dock icon will be the same as the application bundle's icon."]
    #[doc = "  For more information on bundles, see the"]
    #[doc = "  [Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)"]
    #[doc = "  in the Mac Developer Library."]
    #[doc = ""]
    #[doc = "  @remark @osx The first time a window is created the menu bar is populated"]
    #[doc = "  with common commands like Hide, Quit and About.  The About entry opens"]
    #[doc = "  a minimal about dialog with information from the application's bundle.  The"]
    #[doc = "  menu bar can be disabled with a"]
    #[doc = "  [compile-time option](@ref compile_options_osx)."]
    #[doc = ""]
    #[doc = "  @remark @osx On OS X 10.10 and later the window frame will not be rendered"]
    #[doc = "  at full resolution on Retina displays unless the `NSHighResolutionCapable`"]
    #[doc = "  key is enabled in the application bundle's `Info.plist`.  For more"]
    #[doc = "  information, see"]
    #[doc = "  [High Resolution Guidelines for OS X](https://developer.apple.com/library/mac/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Explained/Explained.html)"]
    #[doc = "  in the Mac Developer Library.  The GLFW test and example programs use"]
    #[doc = "  a custom `Info.plist` template for this, which can be found as"]
    #[doc = "  `CMake/MacOSXBundleInfo.plist.in` in the source tree."]
    #[doc = ""]
    #[doc = "  @remark @x11 Some window managers will not respect the placement of"]
    #[doc = "  initially hidden windows."]
    #[doc = ""]
    #[doc = "  @remark @x11 Due to the asynchronous nature of X11, it may take a moment for"]
    #[doc = "  a window to reach its requested state.  This means you may not be able to"]
    #[doc = "  query the final size, position or other attributes directly after window"]
    #[doc = "  creation."]
    #[doc = ""]
    #[doc = "  @reentrancy This function must not be called from a callback."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_creation"]
    #[doc = "  @sa glfwDestroyWindow"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwOpenWindow`."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwCreateWindow(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        title: *const ::std::os::raw::c_char,
        monitor: *mut GLFWmonitor,
        share: *mut GLFWwindow,
    ) -> *mut GLFWwindow;
}
extern "C" {
    #[doc = " @brief Destroys the specified window and its context."]
    #[doc = ""]
    #[doc = "  This function destroys the specified window and its context.  On calling"]
    #[doc = "  this function, no further callbacks will be called for that window."]
    #[doc = ""]
    #[doc = "  If the context of the specified window is current on the main thread, it is"]
    #[doc = "  detached before being destroyed."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to destroy."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @note The context of the specified window must not be current on any other"]
    #[doc = "  thread when this function is called."]
    #[doc = ""]
    #[doc = "  @reentrancy This function must not be called from a callback."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_creation"]
    #[doc = "  @sa glfwCreateWindow"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwCloseWindow`."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwDestroyWindow(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Checks the close flag of the specified window."]
    #[doc = ""]
    #[doc = "  This function returns the value of the close flag of the specified window."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to query."]
    #[doc = "  @return The value of the close flag."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Access is not"]
    #[doc = "  synchronized."]
    #[doc = ""]
    #[doc = "  @sa @ref window_close"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwWindowShouldClose(window: *mut GLFWwindow) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets the close flag of the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the value of the close flag of the specified window."]
    #[doc = "  This can be used to override the user's attempt to close the window, or"]
    #[doc = "  to signal that it should be closed."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose flag to change."]
    #[doc = "  @param[in] value The new value."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Access is not"]
    #[doc = "  synchronized."]
    #[doc = ""]
    #[doc = "  @sa @ref window_close"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowShouldClose(window: *mut GLFWwindow, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Sets the title of the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the window title, encoded as UTF-8, of the specified"]
    #[doc = "  window."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose title to change."]
    #[doc = "  @param[in] title The UTF-8 encoded window title."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark @osx The window title will not be updated until the next time you"]
    #[doc = "  process events."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_title"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowTitle(window: *mut GLFWwindow, title: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief Sets the icon for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the icon of the specified window.  If passed an array of"]
    #[doc = "  candidate images, those of or closest to the sizes desired by the system are"]
    #[doc = "  selected.  If no images are specified, the window reverts to its default"]
    #[doc = "  icon."]
    #[doc = ""]
    #[doc = "  The desired image sizes varies depending on platform and system settings."]
    #[doc = "  The selected images will be rescaled as needed.  Good sizes include 16x16,"]
    #[doc = "  32x32 and 48x48."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose icon to set."]
    #[doc = "  @param[in] count The number of images in the specified array, or zero to"]
    #[doc = "  revert to the default window icon."]
    #[doc = "  @param[in] images The images to create the icon from.  This is ignored if"]
    #[doc = "  count is zero."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The specified image data is copied before this function"]
    #[doc = "  returns."]
    #[doc = ""]
    #[doc = "  @remark @osx The GLFW window has no icon, as it is not a document"]
    #[doc = "  window, so this function does nothing.  The dock icon will be the same as"]
    #[doc = "  the application bundle's icon.  For more information on bundles, see the"]
    #[doc = "  [Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)"]
    #[doc = "  in the Mac Developer Library."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_icon"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowIcon(
        window: *mut GLFWwindow,
        count: ::std::os::raw::c_int,
        images: *const GLFWimage,
    );
}
extern "C" {
    #[doc = " @brief Retrieves the position of the client area of the specified window."]
    #[doc = ""]
    #[doc = "  This function retrieves the position, in screen coordinates, of the"]
    #[doc = "  upper-left corner of the client area of the specified window."]
    #[doc = ""]
    #[doc = "  Any or all of the position arguments may be `NULL`.  If an error occurs, all"]
    #[doc = "  non-`NULL` position arguments will be set to zero."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to query."]
    #[doc = "  @param[out] xpos Where to store the x-coordinate of the upper-left corner of"]
    #[doc = "  the client area, or `NULL`."]
    #[doc = "  @param[out] ypos Where to store the y-coordinate of the upper-left corner of"]
    #[doc = "  the client area, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_pos"]
    #[doc = "  @sa glfwSetWindowPos"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetWindowPos(
        window: *mut GLFWwindow,
        xpos: *mut ::std::os::raw::c_int,
        ypos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the position of the client area of the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the position, in screen coordinates, of the upper-left"]
    #[doc = "  corner of the client area of the specified windowed mode window.  If the"]
    #[doc = "  window is a full screen window, this function does nothing."]
    #[doc = ""]
    #[doc = "  __Do not use this function__ to move an already visible window unless you"]
    #[doc = "  have very good reasons for doing so, as it will confuse and annoy the user."]
    #[doc = ""]
    #[doc = "  The window manager may put limits on what positions are allowed.  GLFW"]
    #[doc = "  cannot and should not override these limits."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to query."]
    #[doc = "  @param[in] xpos The x-coordinate of the upper-left corner of the client area."]
    #[doc = "  @param[in] ypos The y-coordinate of the upper-left corner of the client area."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_pos"]
    #[doc = "  @sa glfwGetWindowPos"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowPos(
        window: *mut GLFWwindow,
        xpos: ::std::os::raw::c_int,
        ypos: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Retrieves the size of the client area of the specified window."]
    #[doc = ""]
    #[doc = "  This function retrieves the size, in screen coordinates, of the client area"]
    #[doc = "  of the specified window.  If you wish to retrieve the size of the"]
    #[doc = "  framebuffer of the window in pixels, see @ref glfwGetFramebufferSize."]
    #[doc = ""]
    #[doc = "  Any or all of the size arguments may be `NULL`.  If an error occurs, all"]
    #[doc = "  non-`NULL` size arguments will be set to zero."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose size to retrieve."]
    #[doc = "  @param[out] width Where to store the width, in screen coordinates, of the"]
    #[doc = "  client area, or `NULL`."]
    #[doc = "  @param[out] height Where to store the height, in screen coordinates, of the"]
    #[doc = "  client area, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_size"]
    #[doc = "  @sa glfwSetWindowSize"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetWindowSize(
        window: *mut GLFWwindow,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the size limits of the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the size limits of the client area of the specified"]
    #[doc = "  window.  If the window is full screen, the size limits only take effect"]
    #[doc = "  once it is made windowed.  If the window is not resizable, this function"]
    #[doc = "  does nothing."]
    #[doc = ""]
    #[doc = "  The size limits are applied immediately to a windowed mode window and may"]
    #[doc = "  cause it to be resized."]
    #[doc = ""]
    #[doc = "  The maximum dimensions must be greater than or equal to the minimum"]
    #[doc = "  dimensions and all must be greater than or equal to zero."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to set limits for."]
    #[doc = "  @param[in] minwidth The minimum width, in screen coordinates, of the client"]
    #[doc = "  area, or `GLFW_DONT_CARE`."]
    #[doc = "  @param[in] minheight The minimum height, in screen coordinates, of the"]
    #[doc = "  client area, or `GLFW_DONT_CARE`."]
    #[doc = "  @param[in] maxwidth The maximum width, in screen coordinates, of the client"]
    #[doc = "  area, or `GLFW_DONT_CARE`."]
    #[doc = "  @param[in] maxheight The maximum height, in screen coordinates, of the"]
    #[doc = "  client area, or `GLFW_DONT_CARE`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark If you set size limits and an aspect ratio that conflict, the"]
    #[doc = "  results are undefined."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_sizelimits"]
    #[doc = "  @sa glfwSetWindowAspectRatio"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowSizeLimits(
        window: *mut GLFWwindow,
        minwidth: ::std::os::raw::c_int,
        minheight: ::std::os::raw::c_int,
        maxwidth: ::std::os::raw::c_int,
        maxheight: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the aspect ratio of the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the required aspect ratio of the client area of the"]
    #[doc = "  specified window.  If the window is full screen, the aspect ratio only takes"]
    #[doc = "  effect once it is made windowed.  If the window is not resizable, this"]
    #[doc = "  function does nothing."]
    #[doc = ""]
    #[doc = "  The aspect ratio is specified as a numerator and a denominator and both"]
    #[doc = "  values must be greater than zero.  For example, the common 16:9 aspect ratio"]
    #[doc = "  is specified as 16 and 9, respectively."]
    #[doc = ""]
    #[doc = "  If the numerator and denominator is set to `GLFW_DONT_CARE` then the aspect"]
    #[doc = "  ratio limit is disabled."]
    #[doc = ""]
    #[doc = "  The aspect ratio is applied immediately to a windowed mode window and may"]
    #[doc = "  cause it to be resized."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to set limits for."]
    #[doc = "  @param[in] numer The numerator of the desired aspect ratio, or"]
    #[doc = "  `GLFW_DONT_CARE`."]
    #[doc = "  @param[in] denom The denominator of the desired aspect ratio, or"]
    #[doc = "  `GLFW_DONT_CARE`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark If you set size limits and an aspect ratio that conflict, the"]
    #[doc = "  results are undefined."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_sizelimits"]
    #[doc = "  @sa glfwSetWindowSizeLimits"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowAspectRatio(
        window: *mut GLFWwindow,
        numer: ::std::os::raw::c_int,
        denom: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the size of the client area of the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the size, in screen coordinates, of the client area of"]
    #[doc = "  the specified window."]
    #[doc = ""]
    #[doc = "  For full screen windows, this function updates the resolution of its desired"]
    #[doc = "  video mode and switches to the video mode closest to it, without affecting"]
    #[doc = "  the window's context.  As the context is unaffected, the bit depths of the"]
    #[doc = "  framebuffer remain unchanged."]
    #[doc = ""]
    #[doc = "  If you wish to update the refresh rate of the desired video mode in addition"]
    #[doc = "  to its resolution, see @ref glfwSetWindowMonitor."]
    #[doc = ""]
    #[doc = "  The window manager may put limits on what sizes are allowed.  GLFW cannot"]
    #[doc = "  and should not override these limits."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to resize."]
    #[doc = "  @param[in] width The desired width, in screen coordinates, of the window"]
    #[doc = "  client area."]
    #[doc = "  @param[in] height The desired height, in screen coordinates, of the window"]
    #[doc = "  client area."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_size"]
    #[doc = "  @sa glfwGetWindowSize"]
    #[doc = "  @sa glfwSetWindowMonitor"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowSize(
        window: *mut GLFWwindow,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Retrieves the size of the framebuffer of the specified window."]
    #[doc = ""]
    #[doc = "  This function retrieves the size, in pixels, of the framebuffer of the"]
    #[doc = "  specified window.  If you wish to retrieve the size of the window in screen"]
    #[doc = "  coordinates, see @ref glfwGetWindowSize."]
    #[doc = ""]
    #[doc = "  Any or all of the size arguments may be `NULL`.  If an error occurs, all"]
    #[doc = "  non-`NULL` size arguments will be set to zero."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose framebuffer to query."]
    #[doc = "  @param[out] width Where to store the width, in pixels, of the framebuffer,"]
    #[doc = "  or `NULL`."]
    #[doc = "  @param[out] height Where to store the height, in pixels, of the framebuffer,"]
    #[doc = "  or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_fbsize"]
    #[doc = "  @sa glfwSetFramebufferSizeCallback"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetFramebufferSize(
        window: *mut GLFWwindow,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Retrieves the size of the frame of the window."]
    #[doc = ""]
    #[doc = "  This function retrieves the size, in screen coordinates, of each edge of the"]
    #[doc = "  frame of the specified window.  This size includes the title bar, if the"]
    #[doc = "  window has one.  The size of the frame may vary depending on the"]
    #[doc = "  [window-related hints](@ref window_hints_wnd) used to create it."]
    #[doc = ""]
    #[doc = "  Because this function retrieves the size of each window frame edge and not"]
    #[doc = "  the offset along a particular coordinate axis, the retrieved values will"]
    #[doc = "  always be zero or positive."]
    #[doc = ""]
    #[doc = "  Any or all of the size arguments may be `NULL`.  If an error occurs, all"]
    #[doc = "  non-`NULL` size arguments will be set to zero."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose frame size to query."]
    #[doc = "  @param[out] left Where to store the size, in screen coordinates, of the left"]
    #[doc = "  edge of the window frame, or `NULL`."]
    #[doc = "  @param[out] top Where to store the size, in screen coordinates, of the top"]
    #[doc = "  edge of the window frame, or `NULL`."]
    #[doc = "  @param[out] right Where to store the size, in screen coordinates, of the"]
    #[doc = "  right edge of the window frame, or `NULL`."]
    #[doc = "  @param[out] bottom Where to store the size, in screen coordinates, of the"]
    #[doc = "  bottom edge of the window frame, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_size"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetWindowFrameSize(
        window: *mut GLFWwindow,
        left: *mut ::std::os::raw::c_int,
        top: *mut ::std::os::raw::c_int,
        right: *mut ::std::os::raw::c_int,
        bottom: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Iconifies the specified window."]
    #[doc = ""]
    #[doc = "  This function iconifies (minimizes) the specified window if it was"]
    #[doc = "  previously restored.  If the window is already iconified, this function does"]
    #[doc = "  nothing."]
    #[doc = ""]
    #[doc = "  If the specified window is a full screen window, the original monitor"]
    #[doc = "  resolution is restored until the window is restored."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to iconify."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_iconify"]
    #[doc = "  @sa glfwRestoreWindow"]
    #[doc = "  @sa glfwMaximizeWindow"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.1."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwIconifyWindow(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Restores the specified window."]
    #[doc = ""]
    #[doc = "  This function restores the specified window if it was previously iconified"]
    #[doc = "  (minimized) or maximized.  If the window is already restored, this function"]
    #[doc = "  does nothing."]
    #[doc = ""]
    #[doc = "  If the specified window is a full screen window, the resolution chosen for"]
    #[doc = "  the window is restored on the selected monitor."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to restore."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_iconify"]
    #[doc = "  @sa glfwIconifyWindow"]
    #[doc = "  @sa glfwMaximizeWindow"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.1."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwRestoreWindow(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Maximizes the specified window."]
    #[doc = ""]
    #[doc = "  This function maximizes the specified window if it was previously not"]
    #[doc = "  maximized.  If the window is already maximized, this function does nothing."]
    #[doc = ""]
    #[doc = "  If the specified window is a full screen window, this function does nothing."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to maximize."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @par Thread Safety"]
    #[doc = "  This function may only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_iconify"]
    #[doc = "  @sa glfwIconifyWindow"]
    #[doc = "  @sa glfwRestoreWindow"]
    #[doc = ""]
    #[doc = "  @since Added in GLFW 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwMaximizeWindow(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Makes the specified window visible."]
    #[doc = ""]
    #[doc = "  This function makes the specified window visible if it was previously"]
    #[doc = "  hidden.  If the window is already visible or is in full screen mode, this"]
    #[doc = "  function does nothing."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to make visible."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_hide"]
    #[doc = "  @sa glfwHideWindow"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwShowWindow(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Hides the specified window."]
    #[doc = ""]
    #[doc = "  This function hides the specified window if it was previously visible.  If"]
    #[doc = "  the window is already hidden or is in full screen mode, this function does"]
    #[doc = "  nothing."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to hide."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_hide"]
    #[doc = "  @sa glfwShowWindow"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwHideWindow(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Brings the specified window to front and sets input focus."]
    #[doc = ""]
    #[doc = "  This function brings the specified window to front and sets input focus."]
    #[doc = "  The window should already be visible and not iconified."]
    #[doc = ""]
    #[doc = "  By default, both windowed and full screen mode windows are focused when"]
    #[doc = "  initially created.  Set the [GLFW_FOCUSED](@ref window_hints_wnd) to disable"]
    #[doc = "  this behavior."]
    #[doc = ""]
    #[doc = "  __Do not use this function__ to steal focus from other applications unless"]
    #[doc = "  you are certain that is what the user wants.  Focus stealing can be"]
    #[doc = "  extremely disruptive."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to give input focus."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_focus"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwFocusWindow(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Returns the monitor that the window uses for full screen mode."]
    #[doc = ""]
    #[doc = "  This function returns the handle of the monitor that the specified window is"]
    #[doc = "  in full screen on."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to query."]
    #[doc = "  @return The monitor, or `NULL` if the window is in windowed mode or an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_monitor"]
    #[doc = "  @sa glfwSetWindowMonitor"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetWindowMonitor(window: *mut GLFWwindow) -> *mut GLFWmonitor;
}
extern "C" {
    #[doc = " @brief Sets the mode, monitor, video mode and placement of a window."]
    #[doc = ""]
    #[doc = "  This function sets the monitor that the window uses for full screen mode or,"]
    #[doc = "  if the monitor is `NULL`, makes it windowed mode."]
    #[doc = ""]
    #[doc = "  When setting a monitor, this function updates the width, height and refresh"]
    #[doc = "  rate of the desired video mode and switches to the video mode closest to it."]
    #[doc = "  The window position is ignored when setting a monitor."]
    #[doc = ""]
    #[doc = "  When the monitor is `NULL`, the position, width and height are used to"]
    #[doc = "  place the window client area.  The refresh rate is ignored when no monitor"]
    #[doc = "  is specified."]
    #[doc = ""]
    #[doc = "  If you only wish to update the resolution of a full screen window or the"]
    #[doc = "  size of a windowed mode window, see @ref glfwSetWindowSize."]
    #[doc = ""]
    #[doc = "  When a window transitions from full screen to windowed mode, this function"]
    #[doc = "  restores any previous window settings such as whether it is decorated,"]
    #[doc = "  floating, resizable, has size or aspect ratio limits, etc.."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose monitor, size or video mode to set."]
    #[doc = "  @param[in] monitor The desired monitor, or `NULL` to set windowed mode."]
    #[doc = "  @param[in] xpos The desired x-coordinate of the upper-left corner of the"]
    #[doc = "  client area."]
    #[doc = "  @param[in] ypos The desired y-coordinate of the upper-left corner of the"]
    #[doc = "  client area."]
    #[doc = "  @param[in] width The desired with, in screen coordinates, of the client area"]
    #[doc = "  or video mode."]
    #[doc = "  @param[in] height The desired height, in screen coordinates, of the client"]
    #[doc = "  area or video mode."]
    #[doc = "  @param[in] refreshRate The desired refresh rate, in Hz, of the video mode,"]
    #[doc = "  or `GLFW_DONT_CARE`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_monitor"]
    #[doc = "  @sa @ref window_full_screen"]
    #[doc = "  @sa glfwGetWindowMonitor"]
    #[doc = "  @sa glfwSetWindowSize"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowMonitor(
        window: *mut GLFWwindow,
        monitor: *mut GLFWmonitor,
        xpos: ::std::os::raw::c_int,
        ypos: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        refreshRate: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Returns an attribute of the specified window."]
    #[doc = ""]
    #[doc = "  This function returns the value of an attribute of the specified window or"]
    #[doc = "  its OpenGL or OpenGL ES context."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to query."]
    #[doc = "  @param[in] attrib The [window attribute](@ref window_attribs) whose value to"]
    #[doc = "  return."]
    #[doc = "  @return The value of the attribute, or zero if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark Framebuffer related hints are not window attributes.  See @ref"]
    #[doc = "  window_attribs_fb for more information."]
    #[doc = ""]
    #[doc = "  @remark Zero is a valid value for many window and context related"]
    #[doc = "  attributes so you cannot use a return value of zero as an indication of"]
    #[doc = "  errors.  However, this function should not fail as long as it is passed"]
    #[doc = "  valid arguments and the library has been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_attribs"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwGetWindowParam` and"]
    #[doc = "  `glfwGetGLVersion`."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetWindowAttrib(
        window: *mut GLFWwindow,
        attrib: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets the user pointer of the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the user-defined pointer of the specified window.  The"]
    #[doc = "  current value is retained until the window is destroyed.  The initial value"]
    #[doc = "  is `NULL`."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose pointer to set."]
    #[doc = "  @param[in] pointer The new value."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Access is not"]
    #[doc = "  synchronized."]
    #[doc = ""]
    #[doc = "  @sa @ref window_userptr"]
    #[doc = "  @sa glfwGetWindowUserPointer"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowUserPointer(window: *mut GLFWwindow, pointer: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @brief Returns the user pointer of the specified window."]
    #[doc = ""]
    #[doc = "  This function returns the current value of the user-defined pointer of the"]
    #[doc = "  specified window.  The initial value is `NULL`."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose pointer to return."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Access is not"]
    #[doc = "  synchronized."]
    #[doc = ""]
    #[doc = "  @sa @ref window_userptr"]
    #[doc = "  @sa glfwSetWindowUserPointer"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetWindowUserPointer(window: *mut GLFWwindow) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Sets the position callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the position callback of the specified window, which is"]
    #[doc = "  called when the window is moved.  The callback is provided with the screen"]
    #[doc = "  position of the upper-left corner of the client area of the window."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] cbfun The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_pos"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowPosCallback(
        window: *mut GLFWwindow,
        cbfun: GLFWwindowposfun,
    ) -> GLFWwindowposfun;
}
extern "C" {
    #[doc = " @brief Sets the size callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the size callback of the specified window, which is"]
    #[doc = "  called when the window is resized.  The callback is provided with the size,"]
    #[doc = "  in screen coordinates, of the client area of the window."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] cbfun The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_size"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter and return value."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowSizeCallback(
        window: *mut GLFWwindow,
        cbfun: GLFWwindowsizefun,
    ) -> GLFWwindowsizefun;
}
extern "C" {
    #[doc = " @brief Sets the close callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the close callback of the specified window, which is"]
    #[doc = "  called when the user attempts to close the window, for example by clicking"]
    #[doc = "  the close widget in the title bar."]
    #[doc = ""]
    #[doc = "  The close flag is set before this callback is called, but you can modify it"]
    #[doc = "  at any time with @ref glfwSetWindowShouldClose."]
    #[doc = ""]
    #[doc = "  The close callback is not triggered by @ref glfwDestroyWindow."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] cbfun The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @remark @osx Selecting Quit from the application menu will trigger the close"]
    #[doc = "  callback for all windows."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_close"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.5."]
    #[doc = "  @glfw3 Added window handle parameter and return value."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowCloseCallback(
        window: *mut GLFWwindow,
        cbfun: GLFWwindowclosefun,
    ) -> GLFWwindowclosefun;
}
extern "C" {
    #[doc = " @brief Sets the refresh callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the refresh callback of the specified window, which is"]
    #[doc = "  called when the client area of the window needs to be redrawn, for example"]
    #[doc = "  if the window has been exposed after having been covered by another window."]
    #[doc = ""]
    #[doc = "  On compositing window systems such as Aero, Compiz or Aqua, where the window"]
    #[doc = "  contents are saved off-screen, this callback may be called only very"]
    #[doc = "  infrequently or never at all."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] cbfun The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_refresh"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.5."]
    #[doc = "  @glfw3 Added window handle parameter and return value."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowRefreshCallback(
        window: *mut GLFWwindow,
        cbfun: GLFWwindowrefreshfun,
    ) -> GLFWwindowrefreshfun;
}
extern "C" {
    #[doc = " @brief Sets the focus callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the focus callback of the specified window, which is"]
    #[doc = "  called when the window gains or loses input focus."]
    #[doc = ""]
    #[doc = "  After the focus callback is called for a window that lost input focus,"]
    #[doc = "  synthetic key and mouse button release events will be generated for all such"]
    #[doc = "  that had been pressed.  For more information, see @ref glfwSetKeyCallback"]
    #[doc = "  and @ref glfwSetMouseButtonCallback."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] cbfun The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_focus"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowFocusCallback(
        window: *mut GLFWwindow,
        cbfun: GLFWwindowfocusfun,
    ) -> GLFWwindowfocusfun;
}
extern "C" {
    #[doc = " @brief Sets the iconify callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the iconification callback of the specified window, which"]
    #[doc = "  is called when the window is iconified or restored."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] cbfun The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_iconify"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowIconifyCallback(
        window: *mut GLFWwindow,
        cbfun: GLFWwindowiconifyfun,
    ) -> GLFWwindowiconifyfun;
}
extern "C" {
    #[doc = " @brief Sets the framebuffer resize callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the framebuffer resize callback of the specified window,"]
    #[doc = "  which is called when the framebuffer of the specified window is resized."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] cbfun The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_fbsize"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetFramebufferSizeCallback(
        window: *mut GLFWwindow,
        cbfun: GLFWframebuffersizefun,
    ) -> GLFWframebuffersizefun;
}
extern "C" {
    #[doc = " @brief Processes all pending events."]
    #[doc = ""]
    #[doc = "  This function processes only those events that are already in the event"]
    #[doc = "  queue and then returns immediately.  Processing events will cause the window"]
    #[doc = "  and input callbacks associated with those events to be called."]
    #[doc = ""]
    #[doc = "  On some platforms, a window move, resize or menu operation will cause event"]
    #[doc = "  processing to block.  This is due to how event processing is designed on"]
    #[doc = "  those platforms.  You can use the"]
    #[doc = "  [window refresh callback](@ref window_refresh) to redraw the contents of"]
    #[doc = "  your window when necessary during such operations."]
    #[doc = ""]
    #[doc = "  On some platforms, certain events are sent directly to the application"]
    #[doc = "  without going through the event queue, causing callbacks to be called"]
    #[doc = "  outside of a call to one of the event processing functions."]
    #[doc = ""]
    #[doc = "  Event processing is not required for joystick input to work."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @reentrancy This function must not be called from a callback."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref events"]
    #[doc = "  @sa glfwWaitEvents"]
    #[doc = "  @sa glfwWaitEventsTimeout"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwPollEvents();
}
extern "C" {
    #[doc = " @brief Waits until events are queued and processes them."]
    #[doc = ""]
    #[doc = "  This function puts the calling thread to sleep until at least one event is"]
    #[doc = "  available in the event queue.  Once one or more events are available,"]
    #[doc = "  it behaves exactly like @ref glfwPollEvents, i.e. the events in the queue"]
    #[doc = "  are processed and the function then returns immediately.  Processing events"]
    #[doc = "  will cause the window and input callbacks associated with those events to be"]
    #[doc = "  called."]
    #[doc = ""]
    #[doc = "  Since not all events are associated with callbacks, this function may return"]
    #[doc = "  without a callback having been called even if you are monitoring all"]
    #[doc = "  callbacks."]
    #[doc = ""]
    #[doc = "  On some platforms, a window move, resize or menu operation will cause event"]
    #[doc = "  processing to block.  This is due to how event processing is designed on"]
    #[doc = "  those platforms.  You can use the"]
    #[doc = "  [window refresh callback](@ref window_refresh) to redraw the contents of"]
    #[doc = "  your window when necessary during such operations."]
    #[doc = ""]
    #[doc = "  On some platforms, certain callbacks may be called outside of a call to one"]
    #[doc = "  of the event processing functions."]
    #[doc = ""]
    #[doc = "  If no windows exist, this function returns immediately.  For synchronization"]
    #[doc = "  of threads in applications that do not create windows, use your threading"]
    #[doc = "  library of choice."]
    #[doc = ""]
    #[doc = "  Event processing is not required for joystick input to work."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @reentrancy This function must not be called from a callback."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref events"]
    #[doc = "  @sa glfwPollEvents"]
    #[doc = "  @sa glfwWaitEventsTimeout"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.5."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwWaitEvents();
}
extern "C" {
    #[doc = " @brief Waits with timeout until events are queued and processes them."]
    #[doc = ""]
    #[doc = "  This function puts the calling thread to sleep until at least one event is"]
    #[doc = "  available in the event queue, or until the specified timeout is reached.  If"]
    #[doc = "  one or more events are available, it behaves exactly like @ref"]
    #[doc = "  glfwPollEvents, i.e. the events in the queue are processed and the function"]
    #[doc = "  then returns immediately.  Processing events will cause the window and input"]
    #[doc = "  callbacks associated with those events to be called."]
    #[doc = ""]
    #[doc = "  The timeout value must be a positive finite number."]
    #[doc = ""]
    #[doc = "  Since not all events are associated with callbacks, this function may return"]
    #[doc = "  without a callback having been called even if you are monitoring all"]
    #[doc = "  callbacks."]
    #[doc = ""]
    #[doc = "  On some platforms, a window move, resize or menu operation will cause event"]
    #[doc = "  processing to block.  This is due to how event processing is designed on"]
    #[doc = "  those platforms.  You can use the"]
    #[doc = "  [window refresh callback](@ref window_refresh) to redraw the contents of"]
    #[doc = "  your window when necessary during such operations."]
    #[doc = ""]
    #[doc = "  On some platforms, certain callbacks may be called outside of a call to one"]
    #[doc = "  of the event processing functions."]
    #[doc = ""]
    #[doc = "  If no windows exist, this function returns immediately.  For synchronization"]
    #[doc = "  of threads in applications that do not create windows, use your threading"]
    #[doc = "  library of choice."]
    #[doc = ""]
    #[doc = "  Event processing is not required for joystick input to work."]
    #[doc = ""]
    #[doc = "  @param[in] timeout The maximum amount of time, in seconds, to wait."]
    #[doc = ""]
    #[doc = "  @reentrancy This function must not be called from a callback."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref events"]
    #[doc = "  @sa glfwPollEvents"]
    #[doc = "  @sa glfwWaitEvents"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwWaitEventsTimeout(timeout: f64);
}
extern "C" {
    #[doc = " @brief Posts an empty event to the event queue."]
    #[doc = ""]
    #[doc = "  This function posts an empty event from the current thread to the event"]
    #[doc = "  queue, causing @ref glfwWaitEvents or @ref glfwWaitEventsTimeout to return."]
    #[doc = ""]
    #[doc = "  If no windows exist, this function returns immediately.  For synchronization"]
    #[doc = "  of threads in applications that do not create windows, use your threading"]
    #[doc = "  library of choice."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref events"]
    #[doc = "  @sa glfwWaitEvents"]
    #[doc = "  @sa glfwWaitEventsTimeout"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwPostEmptyEvent();
}
extern "C" {
    #[doc = " @brief Returns the value of an input option for the specified window."]
    #[doc = ""]
    #[doc = "  This function returns the value of an input option for the specified window."]
    #[doc = "  The mode must be one of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or"]
    #[doc = "  `GLFW_STICKY_MOUSE_BUTTONS`."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to query."]
    #[doc = "  @param[in] mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or"]
    #[doc = "  `GLFW_STICKY_MOUSE_BUTTONS`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_INVALID_ENUM."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa glfwSetInputMode"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetInputMode(
        window: *mut GLFWwindow,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets an input option for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets an input mode option for the specified window.  The mode"]
    #[doc = "  must be one of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or"]
    #[doc = "  `GLFW_STICKY_MOUSE_BUTTONS`."]
    #[doc = ""]
    #[doc = "  If the mode is `GLFW_CURSOR`, the value must be one of the following cursor"]
    #[doc = "  modes:"]
    #[doc = "  - `GLFW_CURSOR_NORMAL` makes the cursor visible and behaving normally."]
    #[doc = "  - `GLFW_CURSOR_HIDDEN` makes the cursor invisible when it is over the client"]
    #[doc = "    area of the window but does not restrict the cursor from leaving."]
    #[doc = "  - `GLFW_CURSOR_DISABLED` hides and grabs the cursor, providing virtual"]
    #[doc = "    and unlimited cursor movement.  This is useful for implementing for"]
    #[doc = "    example 3D camera controls."]
    #[doc = ""]
    #[doc = "  If the mode is `GLFW_STICKY_KEYS`, the value must be either `GLFW_TRUE` to"]
    #[doc = "  enable sticky keys, or `GLFW_FALSE` to disable it.  If sticky keys are"]
    #[doc = "  enabled, a key press will ensure that @ref glfwGetKey returns `GLFW_PRESS`"]
    #[doc = "  the next time it is called even if the key had been released before the"]
    #[doc = "  call.  This is useful when you are only interested in whether keys have been"]
    #[doc = "  pressed but not when or in which order."]
    #[doc = ""]
    #[doc = "  If the mode is `GLFW_STICKY_MOUSE_BUTTONS`, the value must be either"]
    #[doc = "  `GLFW_TRUE` to enable sticky mouse buttons, or `GLFW_FALSE` to disable it."]
    #[doc = "  If sticky mouse buttons are enabled, a mouse button press will ensure that"]
    #[doc = "  @ref glfwGetMouseButton returns `GLFW_PRESS` the next time it is called even"]
    #[doc = "  if the mouse button had been released before the call.  This is useful when"]
    #[doc = "  you are only interested in whether mouse buttons have been pressed but not"]
    #[doc = "  when or in which order."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose input mode to set."]
    #[doc = "  @param[in] mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or"]
    #[doc = "  `GLFW_STICKY_MOUSE_BUTTONS`."]
    #[doc = "  @param[in] value The new value of the specified input mode."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa glfwGetInputMode"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwEnable` and `glfwDisable`."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetInputMode(
        window: *mut GLFWwindow,
        mode: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Returns the localized name of the specified printable key."]
    #[doc = ""]
    #[doc = "  This function returns the localized name of the specified printable key."]
    #[doc = "  This is intended for displaying key bindings to the user."]
    #[doc = ""]
    #[doc = "  If the key is `GLFW_KEY_UNKNOWN`, the scancode is used instead, otherwise"]
    #[doc = "  the scancode is ignored.  If a non-printable key or (if the key is"]
    #[doc = "  `GLFW_KEY_UNKNOWN`) a scancode that maps to a non-printable key is"]
    #[doc = "  specified, this function returns `NULL`."]
    #[doc = ""]
    #[doc = "  This behavior allows you to pass in the arguments passed to the"]
    #[doc = "  [key callback](@ref input_key) without modification."]
    #[doc = ""]
    #[doc = "  The printable keys are:"]
    #[doc = "  - `GLFW_KEY_APOSTROPHE`"]
    #[doc = "  - `GLFW_KEY_COMMA`"]
    #[doc = "  - `GLFW_KEY_MINUS`"]
    #[doc = "  - `GLFW_KEY_PERIOD`"]
    #[doc = "  - `GLFW_KEY_SLASH`"]
    #[doc = "  - `GLFW_KEY_SEMICOLON`"]
    #[doc = "  - `GLFW_KEY_EQUAL`"]
    #[doc = "  - `GLFW_KEY_LEFT_BRACKET`"]
    #[doc = "  - `GLFW_KEY_RIGHT_BRACKET`"]
    #[doc = "  - `GLFW_KEY_BACKSLASH`"]
    #[doc = "  - `GLFW_KEY_WORLD_1`"]
    #[doc = "  - `GLFW_KEY_WORLD_2`"]
    #[doc = "  - `GLFW_KEY_0` to `GLFW_KEY_9`"]
    #[doc = "  - `GLFW_KEY_A` to `GLFW_KEY_Z`"]
    #[doc = "  - `GLFW_KEY_KP_0` to `GLFW_KEY_KP_9`"]
    #[doc = "  - `GLFW_KEY_KP_DECIMAL`"]
    #[doc = "  - `GLFW_KEY_KP_DIVIDE`"]
    #[doc = "  - `GLFW_KEY_KP_MULTIPLY`"]
    #[doc = "  - `GLFW_KEY_KP_SUBTRACT`"]
    #[doc = "  - `GLFW_KEY_KP_ADD`"]
    #[doc = "  - `GLFW_KEY_KP_EQUAL`"]
    #[doc = ""]
    #[doc = "  @param[in] key The key to query, or `GLFW_KEY_UNKNOWN`."]
    #[doc = "  @param[in] scancode The scancode of the key to query."]
    #[doc = "  @return The localized name of the key, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned string is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the next call to @ref"]
    #[doc = "  glfwGetKeyName, or until the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref input_key_name"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetKeyName(
        key: ::std::os::raw::c_int,
        scancode: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns the last reported state of a keyboard key for the specified"]
    #[doc = "  window."]
    #[doc = ""]
    #[doc = "  This function returns the last state reported for the specified key to the"]
    #[doc = "  specified window.  The returned state is one of `GLFW_PRESS` or"]
    #[doc = "  `GLFW_RELEASE`.  The higher-level action `GLFW_REPEAT` is only reported to"]
    #[doc = "  the key callback."]
    #[doc = ""]
    #[doc = "  If the `GLFW_STICKY_KEYS` input mode is enabled, this function returns"]
    #[doc = "  `GLFW_PRESS` the first time you call it for a key that was pressed, even if"]
    #[doc = "  that key has already been released."]
    #[doc = ""]
    #[doc = "  The key functions deal with physical keys, with [key tokens](@ref keys)"]
    #[doc = "  named after their use on the standard US keyboard layout.  If you want to"]
    #[doc = "  input text, use the Unicode character callback instead."]
    #[doc = ""]
    #[doc = "  The [modifier key bit masks](@ref mods) are not key tokens and cannot be"]
    #[doc = "  used with this function."]
    #[doc = ""]
    #[doc = "  __Do not use this function__ to implement [text input](@ref input_char)."]
    #[doc = ""]
    #[doc = "  @param[in] window The desired window."]
    #[doc = "  @param[in] key The desired [keyboard key](@ref keys).  `GLFW_KEY_UNKNOWN` is"]
    #[doc = "  not a valid key for this function."]
    #[doc = "  @return One of `GLFW_PRESS` or `GLFW_RELEASE`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_INVALID_ENUM."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref input_key"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetKey(window: *mut GLFWwindow, key: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the last reported state of a mouse button for the specified"]
    #[doc = "  window."]
    #[doc = ""]
    #[doc = "  This function returns the last state reported for the specified mouse button"]
    #[doc = "  to the specified window.  The returned state is one of `GLFW_PRESS` or"]
    #[doc = "  `GLFW_RELEASE`."]
    #[doc = ""]
    #[doc = "  If the `GLFW_STICKY_MOUSE_BUTTONS` input mode is enabled, this function"]
    #[doc = "  `GLFW_PRESS` the first time you call it for a mouse button that was pressed,"]
    #[doc = "  even if that mouse button has already been released."]
    #[doc = ""]
    #[doc = "  @param[in] window The desired window."]
    #[doc = "  @param[in] button The desired [mouse button](@ref buttons)."]
    #[doc = "  @return One of `GLFW_PRESS` or `GLFW_RELEASE`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_INVALID_ENUM."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref input_mouse_button"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetMouseButton(
        window: *mut GLFWwindow,
        button: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieves the position of the cursor relative to the client area of"]
    #[doc = "  the window."]
    #[doc = ""]
    #[doc = "  This function returns the position of the cursor, in screen coordinates,"]
    #[doc = "  relative to the upper-left corner of the client area of the specified"]
    #[doc = "  window."]
    #[doc = ""]
    #[doc = "  If the cursor is disabled (with `GLFW_CURSOR_DISABLED`) then the cursor"]
    #[doc = "  position is unbounded and limited only by the minimum and maximum values of"]
    #[doc = "  a `double`."]
    #[doc = ""]
    #[doc = "  The coordinate can be converted to their integer equivalents with the"]
    #[doc = "  `floor` function.  Casting directly to an integer type works for positive"]
    #[doc = "  coordinates, but fails for negative ones."]
    #[doc = ""]
    #[doc = "  Any or all of the position arguments may be `NULL`.  If an error occurs, all"]
    #[doc = "  non-`NULL` position arguments will be set to zero."]
    #[doc = ""]
    #[doc = "  @param[in] window The desired window."]
    #[doc = "  @param[out] xpos Where to store the cursor x-coordinate, relative to the"]
    #[doc = "  left edge of the client area, or `NULL`."]
    #[doc = "  @param[out] ypos Where to store the cursor y-coordinate, relative to the to"]
    #[doc = "  top edge of the client area, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_pos"]
    #[doc = "  @sa glfwSetCursorPos"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwGetMousePos`."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetCursorPos(window: *mut GLFWwindow, xpos: *mut f64, ypos: *mut f64);
}
extern "C" {
    #[doc = " @brief Sets the position of the cursor, relative to the client area of the"]
    #[doc = "  window."]
    #[doc = ""]
    #[doc = "  This function sets the position, in screen coordinates, of the cursor"]
    #[doc = "  relative to the upper-left corner of the client area of the specified"]
    #[doc = "  window.  The window must have input focus.  If the window does not have"]
    #[doc = "  input focus when this function is called, it fails silently."]
    #[doc = ""]
    #[doc = "  __Do not use this function__ to implement things like camera controls.  GLFW"]
    #[doc = "  already provides the `GLFW_CURSOR_DISABLED` cursor mode that hides the"]
    #[doc = "  cursor, transparently re-centers it and provides unconstrained cursor"]
    #[doc = "  motion.  See @ref glfwSetInputMode for more information."]
    #[doc = ""]
    #[doc = "  If the cursor mode is `GLFW_CURSOR_DISABLED` then the cursor position is"]
    #[doc = "  unconstrained and limited only by the minimum and maximum values of"]
    #[doc = "  a `double`."]
    #[doc = ""]
    #[doc = "  @param[in] window The desired window."]
    #[doc = "  @param[in] xpos The desired x-coordinate, relative to the left edge of the"]
    #[doc = "  client area."]
    #[doc = "  @param[in] ypos The desired y-coordinate, relative to the top edge of the"]
    #[doc = "  client area."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_pos"]
    #[doc = "  @sa glfwGetCursorPos"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwSetMousePos`."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetCursorPos(window: *mut GLFWwindow, xpos: f64, ypos: f64);
}
extern "C" {
    #[doc = " @brief Creates a custom cursor."]
    #[doc = ""]
    #[doc = "  Creates a new custom cursor image that can be set for a window with @ref"]
    #[doc = "  glfwSetCursor.  The cursor can be destroyed with @ref glfwDestroyCursor."]
    #[doc = "  Any remaining cursors are destroyed by @ref glfwTerminate."]
    #[doc = ""]
    #[doc = "  The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight"]
    #[doc = "  bits per channel.  They are arranged canonically as packed sequential rows,"]
    #[doc = "  starting from the top-left corner."]
    #[doc = ""]
    #[doc = "  The cursor hotspot is specified in pixels, relative to the upper-left corner"]
    #[doc = "  of the cursor image.  Like all other coordinate systems in GLFW, the X-axis"]
    #[doc = "  points to the right and the Y-axis points down."]
    #[doc = ""]
    #[doc = "  @param[in] image The desired cursor image."]
    #[doc = "  @param[in] xhot The desired x-coordinate, in pixels, of the cursor hotspot."]
    #[doc = "  @param[in] yhot The desired y-coordinate, in pixels, of the cursor hotspot."]
    #[doc = "  @return The handle of the created cursor, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The specified image data is copied before this function"]
    #[doc = "  returns."]
    #[doc = ""]
    #[doc = "  @reentrancy This function must not be called from a callback."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_object"]
    #[doc = "  @sa glfwDestroyCursor"]
    #[doc = "  @sa glfwCreateStandardCursor"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwCreateCursor(
        image: *const GLFWimage,
        xhot: ::std::os::raw::c_int,
        yhot: ::std::os::raw::c_int,
    ) -> *mut GLFWcursor;
}
extern "C" {
    #[doc = " @brief Creates a cursor with a standard shape."]
    #[doc = ""]
    #[doc = "  Returns a cursor with a [standard shape](@ref shapes), that can be set for"]
    #[doc = "  a window with @ref glfwSetCursor."]
    #[doc = ""]
    #[doc = "  @param[in] shape One of the [standard shapes](@ref shapes)."]
    #[doc = "  @return A new cursor ready to use or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @reentrancy This function must not be called from a callback."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_object"]
    #[doc = "  @sa glfwCreateCursor"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwCreateStandardCursor(shape: ::std::os::raw::c_int) -> *mut GLFWcursor;
}
extern "C" {
    #[doc = " @brief Destroys a cursor."]
    #[doc = ""]
    #[doc = "  This function destroys a cursor previously created with @ref"]
    #[doc = "  glfwCreateCursor.  Any remaining cursors will be destroyed by @ref"]
    #[doc = "  glfwTerminate."]
    #[doc = ""]
    #[doc = "  @param[in] cursor The cursor object to destroy."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @reentrancy This function must not be called from a callback."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_object"]
    #[doc = "  @sa glfwCreateCursor"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwDestroyCursor(cursor: *mut GLFWcursor);
}
extern "C" {
    #[doc = " @brief Sets the cursor for the window."]
    #[doc = ""]
    #[doc = "  This function sets the cursor image to be used when the cursor is over the"]
    #[doc = "  client area of the specified window.  The set cursor will only be visible"]
    #[doc = "  when the [cursor mode](@ref cursor_mode) of the window is"]
    #[doc = "  `GLFW_CURSOR_NORMAL`."]
    #[doc = ""]
    #[doc = "  On some platforms, the set cursor may not be visible unless the window also"]
    #[doc = "  has input focus."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to set the cursor for."]
    #[doc = "  @param[in] cursor The cursor to set, or `NULL` to switch back to the default"]
    #[doc = "  arrow cursor."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_object"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetCursor(window: *mut GLFWwindow, cursor: *mut GLFWcursor);
}
extern "C" {
    #[doc = " @brief Sets the key callback."]
    #[doc = ""]
    #[doc = "  This function sets the key callback of the specified window, which is called"]
    #[doc = "  when a key is pressed, repeated or released."]
    #[doc = ""]
    #[doc = "  The key functions deal with physical keys, with layout independent"]
    #[doc = "  [key tokens](@ref keys) named after their values in the standard US keyboard"]
    #[doc = "  layout.  If you want to input text, use the"]
    #[doc = "  [character callback](@ref glfwSetCharCallback) instead."]
    #[doc = ""]
    #[doc = "  When a window loses input focus, it will generate synthetic key release"]
    #[doc = "  events for all pressed keys.  You can tell these events from user-generated"]
    #[doc = "  events by the fact that the synthetic ones are generated after the focus"]
    #[doc = "  loss event has been processed, i.e. after the"]
    #[doc = "  [window focus callback](@ref glfwSetWindowFocusCallback) has been called."]
    #[doc = ""]
    #[doc = "  The scancode of a key is specific to that platform or sometimes even to that"]
    #[doc = "  machine.  Scancodes are intended to allow users to bind keys that don't have"]
    #[doc = "  a GLFW key token.  Such keys have `key` set to `GLFW_KEY_UNKNOWN`, their"]
    #[doc = "  state is not saved and so it cannot be queried with @ref glfwGetKey."]
    #[doc = ""]
    #[doc = "  Sometimes GLFW needs to generate synthetic key events, in which case the"]
    #[doc = "  scancode may be zero."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] cbfun The new key callback, or `NULL` to remove the currently"]
    #[doc = "  set callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref input_key"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter and return value."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetKeyCallback(window: *mut GLFWwindow, cbfun: GLFWkeyfun) -> GLFWkeyfun;
}
extern "C" {
    #[doc = " @brief Sets the Unicode character callback."]
    #[doc = ""]
    #[doc = "  This function sets the character callback of the specified window, which is"]
    #[doc = "  called when a Unicode character is input."]
    #[doc = ""]
    #[doc = "  The character callback is intended for Unicode text input.  As it deals with"]
    #[doc = "  characters, it is keyboard layout dependent, whereas the"]
    #[doc = "  [key callback](@ref glfwSetKeyCallback) is not.  Characters do not map 1:1"]
    #[doc = "  to physical keys, as a key may produce zero, one or more characters.  If you"]
    #[doc = "  want to know whether a specific physical key was pressed or released, see"]
    #[doc = "  the key callback instead."]
    #[doc = ""]
    #[doc = "  The character callback behaves as system text input normally does and will"]
    #[doc = "  not be called if modifier keys are held down that would prevent normal text"]
    #[doc = "  input on that platform, for example a Super (Command) key on OS X or Alt key"]
    #[doc = "  on Windows.  There is a"]
    #[doc = "  [character with modifiers callback](@ref glfwSetCharModsCallback) that"]
    #[doc = "  receives these events."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] cbfun The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref input_char"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.4."]
    #[doc = "  @glfw3 Added window handle parameter and return value."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetCharCallback(window: *mut GLFWwindow, cbfun: GLFWcharfun) -> GLFWcharfun;
}
extern "C" {
    #[doc = " @brief Sets the Unicode character with modifiers callback."]
    #[doc = ""]
    #[doc = "  This function sets the character with modifiers callback of the specified"]
    #[doc = "  window, which is called when a Unicode character is input regardless of what"]
    #[doc = "  modifier keys are used."]
    #[doc = ""]
    #[doc = "  The character with modifiers callback is intended for implementing custom"]
    #[doc = "  Unicode character input.  For regular Unicode text input, see the"]
    #[doc = "  [character callback](@ref glfwSetCharCallback).  Like the character"]
    #[doc = "  callback, the character with modifiers callback deals with characters and is"]
    #[doc = "  keyboard layout dependent.  Characters do not map 1:1 to physical keys, as"]
    #[doc = "  a key may produce zero, one or more characters.  If you want to know whether"]
    #[doc = "  a specific physical key was pressed or released, see the"]
    #[doc = "  [key callback](@ref glfwSetKeyCallback) instead."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] cbfun The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref input_char"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetCharModsCallback(
        window: *mut GLFWwindow,
        cbfun: GLFWcharmodsfun,
    ) -> GLFWcharmodsfun;
}
extern "C" {
    #[doc = " @brief Sets the mouse button callback."]
    #[doc = ""]
    #[doc = "  This function sets the mouse button callback of the specified window, which"]
    #[doc = "  is called when a mouse button is pressed or released."]
    #[doc = ""]
    #[doc = "  When a window loses input focus, it will generate synthetic mouse button"]
    #[doc = "  release events for all pressed mouse buttons.  You can tell these events"]
    #[doc = "  from user-generated events by the fact that the synthetic ones are generated"]
    #[doc = "  after the focus loss event has been processed, i.e. after the"]
    #[doc = "  [window focus callback](@ref glfwSetWindowFocusCallback) has been called."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] cbfun The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref input_mouse_button"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter and return value."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetMouseButtonCallback(
        window: *mut GLFWwindow,
        cbfun: GLFWmousebuttonfun,
    ) -> GLFWmousebuttonfun;
}
extern "C" {
    #[doc = " @brief Sets the cursor position callback."]
    #[doc = ""]
    #[doc = "  This function sets the cursor position callback of the specified window,"]
    #[doc = "  which is called when the cursor is moved.  The callback is provided with the"]
    #[doc = "  position, in screen coordinates, relative to the upper-left corner of the"]
    #[doc = "  client area of the window."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] cbfun The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_pos"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwSetMousePosCallback`."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetCursorPosCallback(
        window: *mut GLFWwindow,
        cbfun: GLFWcursorposfun,
    ) -> GLFWcursorposfun;
}
extern "C" {
    #[doc = " @brief Sets the cursor enter/exit callback."]
    #[doc = ""]
    #[doc = "  This function sets the cursor boundary crossing callback of the specified"]
    #[doc = "  window, which is called when the cursor enters or leaves the client area of"]
    #[doc = "  the window."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] cbfun The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_enter"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetCursorEnterCallback(
        window: *mut GLFWwindow,
        cbfun: GLFWcursorenterfun,
    ) -> GLFWcursorenterfun;
}
extern "C" {
    #[doc = " @brief Sets the scroll callback."]
    #[doc = ""]
    #[doc = "  This function sets the scroll callback of the specified window, which is"]
    #[doc = "  called when a scrolling device is used, such as a mouse wheel or scrolling"]
    #[doc = "  area of a touchpad."]
    #[doc = ""]
    #[doc = "  The scroll callback receives all scrolling input, like that from a mouse"]
    #[doc = "  wheel or a touchpad scrolling area."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] cbfun The new scroll callback, or `NULL` to remove the currently"]
    #[doc = "  set callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref scrolling"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwSetMouseWheelCallback`."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetScrollCallback(window: *mut GLFWwindow, cbfun: GLFWscrollfun) -> GLFWscrollfun;
}
extern "C" {
    #[doc = " @brief Sets the file drop callback."]
    #[doc = ""]
    #[doc = "  This function sets the file drop callback of the specified window, which is"]
    #[doc = "  called when one or more dragged files are dropped on the window."]
    #[doc = ""]
    #[doc = "  Because the path array and its strings may have been generated specifically"]
    #[doc = "  for that event, they are not guaranteed to be valid after the callback has"]
    #[doc = "  returned.  If you wish to use them after the callback returns, you need to"]
    #[doc = "  make a deep copy."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] cbfun The new file drop callback, or `NULL` to remove the"]
    #[doc = "  currently set callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref path_drop"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetDropCallback(window: *mut GLFWwindow, cbfun: GLFWdropfun) -> GLFWdropfun;
}
extern "C" {
    #[doc = " @brief Returns whether the specified joystick is present."]
    #[doc = ""]
    #[doc = "  This function returns whether the specified joystick is present."]
    #[doc = ""]
    #[doc = "  @param[in] joy The [joystick](@ref joysticks) to query."]
    #[doc = "  @return `GLFW_TRUE` if the joystick is present, or `GLFW_FALSE` otherwise."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref joystick"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwGetJoystickParam`."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwJoystickPresent(joy: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the values of all axes of the specified joystick."]
    #[doc = ""]
    #[doc = "  This function returns the values of all axes of the specified joystick."]
    #[doc = "  Each element in the array is a value between -1.0 and 1.0."]
    #[doc = ""]
    #[doc = "  Querying a joystick slot with no device present is not an error, but will"]
    #[doc = "  cause this function to return `NULL`.  Call @ref glfwJoystickPresent to"]
    #[doc = "  check device presence."]
    #[doc = ""]
    #[doc = "  @param[in] joy The [joystick](@ref joysticks) to query."]
    #[doc = "  @param[out] count Where to store the number of axis values in the returned"]
    #[doc = "  array.  This is set to zero if the joystick is not present or an error"]
    #[doc = "  occurred."]
    #[doc = "  @return An array of axis values, or `NULL` if the joystick is not present or"]
    #[doc = "  an [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned array is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the specified joystick is"]
    #[doc = "  disconnected, this function is called again for that joystick or the library"]
    #[doc = "  is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref joystick_axis"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwGetJoystickPos`."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetJoystickAxes(
        joy: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *const f32;
}
extern "C" {
    #[doc = " @brief Returns the state of all buttons of the specified joystick."]
    #[doc = ""]
    #[doc = "  This function returns the state of all buttons of the specified joystick."]
    #[doc = "  Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`."]
    #[doc = ""]
    #[doc = "  Querying a joystick slot with no device present is not an error, but will"]
    #[doc = "  cause this function to return `NULL`.  Call @ref glfwJoystickPresent to"]
    #[doc = "  check device presence."]
    #[doc = ""]
    #[doc = "  @param[in] joy The [joystick](@ref joysticks) to query."]
    #[doc = "  @param[out] count Where to store the number of button states in the returned"]
    #[doc = "  array.  This is set to zero if the joystick is not present or an error"]
    #[doc = "  occurred."]
    #[doc = "  @return An array of button states, or `NULL` if the joystick is not present"]
    #[doc = "  or an [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned array is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the specified joystick is"]
    #[doc = "  disconnected, this function is called again for that joystick or the library"]
    #[doc = "  is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref joystick_button"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.2."]
    #[doc = "  @glfw3 Changed to return a dynamic array."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetJoystickButtons(
        joy: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " @brief Returns the name of the specified joystick."]
    #[doc = ""]
    #[doc = "  This function returns the name, encoded as UTF-8, of the specified joystick."]
    #[doc = "  The returned string is allocated and freed by GLFW.  You should not free it"]
    #[doc = "  yourself."]
    #[doc = ""]
    #[doc = "  Querying a joystick slot with no device present is not an error, but will"]
    #[doc = "  cause this function to return `NULL`.  Call @ref glfwJoystickPresent to"]
    #[doc = "  check device presence."]
    #[doc = ""]
    #[doc = "  @param[in] joy The [joystick](@ref joysticks) to query."]
    #[doc = "  @return The UTF-8 encoded name of the joystick, or `NULL` if the joystick"]
    #[doc = "  is not present or an [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned string is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the specified joystick is"]
    #[doc = "  disconnected, this function is called again for that joystick or the library"]
    #[doc = "  is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref joystick_name"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetJoystickName(joy: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Sets the joystick configuration callback."]
    #[doc = ""]
    #[doc = "  This function sets the joystick configuration callback, or removes the"]
    #[doc = "  currently set callback.  This is called when a joystick is connected to or"]
    #[doc = "  disconnected from the system."]
    #[doc = ""]
    #[doc = "  @param[in] cbfun The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref joystick_event"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetJoystickCallback(cbfun: GLFWjoystickfun) -> GLFWjoystickfun;
}
extern "C" {
    #[doc = " @brief Sets the clipboard to the specified string."]
    #[doc = ""]
    #[doc = "  This function sets the system clipboard to the specified, UTF-8 encoded"]
    #[doc = "  string."]
    #[doc = ""]
    #[doc = "  @param[in] window The window that will own the clipboard contents."]
    #[doc = "  @param[in] string A UTF-8 encoded string."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The specified string is copied before this function"]
    #[doc = "  returns."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref clipboard"]
    #[doc = "  @sa glfwGetClipboardString"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetClipboardString(window: *mut GLFWwindow, string: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief Returns the contents of the clipboard as a string."]
    #[doc = ""]
    #[doc = "  This function returns the contents of the system clipboard, if it contains"]
    #[doc = "  or is convertible to a UTF-8 encoded string.  If the clipboard is empty or"]
    #[doc = "  if its contents cannot be converted, `NULL` is returned and a @ref"]
    #[doc = "  GLFW_FORMAT_UNAVAILABLE error is generated."]
    #[doc = ""]
    #[doc = "  @param[in] window The window that will request the clipboard contents."]
    #[doc = "  @return The contents of the clipboard as a UTF-8 encoded string, or `NULL`"]
    #[doc = "  if an [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned string is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the next call to @ref"]
    #[doc = "  glfwGetClipboardString or @ref glfwSetClipboardString, or until the library"]
    #[doc = "  is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref clipboard"]
    #[doc = "  @sa glfwSetClipboardString"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetClipboardString(window: *mut GLFWwindow) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns the value of the GLFW timer."]
    #[doc = ""]
    #[doc = "  This function returns the value of the GLFW timer.  Unless the timer has"]
    #[doc = "  been set using @ref glfwSetTime, the timer measures time elapsed since GLFW"]
    #[doc = "  was initialized."]
    #[doc = ""]
    #[doc = "  The resolution of the timer is system dependent, but is usually on the order"]
    #[doc = "  of a few micro- or nanoseconds.  It uses the highest-resolution monotonic"]
    #[doc = "  time source on each supported platform."]
    #[doc = ""]
    #[doc = "  @return The current value, in seconds, or zero if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Reading and"]
    #[doc = "  writing of the internal timer offset is not atomic, so it needs to be"]
    #[doc = "  externally synchronized with calls to @ref glfwSetTime."]
    #[doc = ""]
    #[doc = "  @sa @ref time"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetTime() -> f64;
}
extern "C" {
    #[doc = " @brief Sets the GLFW timer."]
    #[doc = ""]
    #[doc = "  This function sets the value of the GLFW timer.  It then continues to count"]
    #[doc = "  up from that value.  The value must be a positive finite number less than"]
    #[doc = "  or equal to 18446744073.0, which is approximately 584.5 years."]
    #[doc = ""]
    #[doc = "  @param[in] time The new value, in seconds."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_INVALID_VALUE."]
    #[doc = ""]
    #[doc = "  @remark The upper limit of the timer is calculated as"]
    #[doc = "  floor((2<sup>64</sup> - 1) / 10<sup>9</sup>) and is due to implementations"]
    #[doc = "  storing nanoseconds in 64 bits.  The limit may be increased in the future."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Reading and"]
    #[doc = "  writing of the internal timer offset is not atomic, so it needs to be"]
    #[doc = "  externally synchronized with calls to @ref glfwGetTime."]
    #[doc = ""]
    #[doc = "  @sa @ref time"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.2."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetTime(time: f64);
}
extern "C" {
    #[doc = " @brief Returns the current value of the raw timer."]
    #[doc = ""]
    #[doc = "  This function returns the current value of the raw timer, measured in"]
    #[doc = "  1&nbsp;/&nbsp;frequency seconds.  To get the frequency, call @ref"]
    #[doc = "  glfwGetTimerFrequency."]
    #[doc = ""]
    #[doc = "  @return The value of the timer, or zero if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref time"]
    #[doc = "  @sa glfwGetTimerFrequency"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetTimerValue() -> u64;
}
extern "C" {
    #[doc = " @brief Returns the frequency, in Hz, of the raw timer."]
    #[doc = ""]
    #[doc = "  This function returns the frequency, in Hz, of the raw timer."]
    #[doc = ""]
    #[doc = "  @return The frequency of the timer, in Hz, or zero if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref time"]
    #[doc = "  @sa glfwGetTimerValue"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetTimerFrequency() -> u64;
}
extern "C" {
    #[doc = " @brief Makes the context of the specified window current for the calling"]
    #[doc = "  thread."]
    #[doc = ""]
    #[doc = "  This function makes the OpenGL or OpenGL ES context of the specified window"]
    #[doc = "  current on the calling thread.  A context can only be made current on"]
    #[doc = "  a single thread at a time and each thread can have only a single current"]
    #[doc = "  context at a time."]
    #[doc = ""]
    #[doc = "  By default, making a context non-current implicitly forces a pipeline flush."]
    #[doc = "  On machines that support `GL_KHR_context_flush_control`, you can control"]
    #[doc = "  whether a context performs this flush by setting the"]
    #[doc = "  [GLFW_CONTEXT_RELEASE_BEHAVIOR](@ref window_hints_ctx) window hint."]
    #[doc = ""]
    #[doc = "  The specified window must have an OpenGL or OpenGL ES context.  Specifying"]
    #[doc = "  a window without a context will generate a @ref GLFW_NO_WINDOW_CONTEXT"]
    #[doc = "  error."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose context to make current, or `NULL` to"]
    #[doc = "  detach the current context."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_NO_WINDOW_CONTEXT and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref context_current"]
    #[doc = "  @sa glfwGetCurrentContext"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup context"]
    pub fn glfwMakeContextCurrent(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Returns the window whose context is current on the calling thread."]
    #[doc = ""]
    #[doc = "  This function returns the window whose OpenGL or OpenGL ES context is"]
    #[doc = "  current on the calling thread."]
    #[doc = ""]
    #[doc = "  @return The window whose context is current, or `NULL` if no window's"]
    #[doc = "  context is current."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref context_current"]
    #[doc = "  @sa glfwMakeContextCurrent"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup context"]
    pub fn glfwGetCurrentContext() -> *mut GLFWwindow;
}
extern "C" {
    #[doc = " @brief Swaps the front and back buffers of the specified window."]
    #[doc = ""]
    #[doc = "  This function swaps the front and back buffers of the specified window when"]
    #[doc = "  rendering with OpenGL or OpenGL ES.  If the swap interval is greater than"]
    #[doc = "  zero, the GPU driver waits the specified number of screen updates before"]
    #[doc = "  swapping the buffers."]
    #[doc = ""]
    #[doc = "  The specified window must have an OpenGL or OpenGL ES context.  Specifying"]
    #[doc = "  a window without a context will generate a @ref GLFW_NO_WINDOW_CONTEXT"]
    #[doc = "  error."]
    #[doc = ""]
    #[doc = "  This function does not apply to Vulkan.  If you are rendering with Vulkan,"]
    #[doc = "  see `vkQueuePresentKHR` instead."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose buffers to swap."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_NO_WINDOW_CONTEXT and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark __EGL:__ The context of the specified window must be current on the"]
    #[doc = "  calling thread."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref buffer_swap"]
    #[doc = "  @sa glfwSwapInterval"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSwapBuffers(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Sets the swap interval for the current context."]
    #[doc = ""]
    #[doc = "  This function sets the swap interval for the current OpenGL or OpenGL ES"]
    #[doc = "  context, i.e. the number of screen updates to wait from the time @ref"]
    #[doc = "  glfwSwapBuffers was called before swapping the buffers and returning.  This"]
    #[doc = "  is sometimes called _vertical synchronization_, _vertical retrace"]
    #[doc = "  synchronization_ or just _vsync_."]
    #[doc = ""]
    #[doc = "  Contexts that support either of the `WGL_EXT_swap_control_tear` and"]
    #[doc = "  `GLX_EXT_swap_control_tear` extensions also accept negative swap intervals,"]
    #[doc = "  which allow the driver to swap even if a frame arrives a little bit late."]
    #[doc = "  You can check for the presence of these extensions using @ref"]
    #[doc = "  glfwExtensionSupported.  For more information about swap tearing, see the"]
    #[doc = "  extension specifications."]
    #[doc = ""]
    #[doc = "  A context must be current on the calling thread.  Calling this function"]
    #[doc = "  without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error."]
    #[doc = ""]
    #[doc = "  This function does not apply to Vulkan.  If you are rendering with Vulkan,"]
    #[doc = "  see the present mode of your swapchain instead."]
    #[doc = ""]
    #[doc = "  @param[in] interval The minimum number of screen updates to wait for"]
    #[doc = "  until the buffers are swapped by @ref glfwSwapBuffers."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_NO_CURRENT_CONTEXT and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark This function is not called during context creation, leaving the"]
    #[doc = "  swap interval set to whatever is the default on that platform.  This is done"]
    #[doc = "  because some swap interval extensions used by GLFW do not allow the swap"]
    #[doc = "  interval to be reset to zero once it has been set to a non-zero value."]
    #[doc = ""]
    #[doc = "  @remark Some GPU drivers do not honor the requested swap interval, either"]
    #[doc = "  because of a user setting that overrides the application's request or due to"]
    #[doc = "  bugs in the driver."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref buffer_swap"]
    #[doc = "  @sa glfwSwapBuffers"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup context"]
    pub fn glfwSwapInterval(interval: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Returns whether the specified extension is available."]
    #[doc = ""]
    #[doc = "  This function returns whether the specified"]
    #[doc = "  [API extension](@ref context_glext) is supported by the current OpenGL or"]
    #[doc = "  OpenGL ES context.  It searches both for client API extension and context"]
    #[doc = "  creation API extensions."]
    #[doc = ""]
    #[doc = "  A context must be current on the calling thread.  Calling this function"]
    #[doc = "  without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error."]
    #[doc = ""]
    #[doc = "  As this functions retrieves and searches one or more extension strings each"]
    #[doc = "  call, it is recommended that you cache its results if it is going to be used"]
    #[doc = "  frequently.  The extension strings will not change during the lifetime of"]
    #[doc = "  a context, so there is no danger in doing this."]
    #[doc = ""]
    #[doc = "  This function does not apply to Vulkan.  If you are using Vulkan, see @ref"]
    #[doc = "  glfwGetRequiredInstanceExtensions, `vkEnumerateInstanceExtensionProperties`"]
    #[doc = "  and `vkEnumerateDeviceExtensionProperties` instead."]
    #[doc = ""]
    #[doc = "  @param[in] extension The ASCII encoded name of the extension."]
    #[doc = "  @return `GLFW_TRUE` if the extension is available, or `GLFW_FALSE`"]
    #[doc = "  otherwise."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_NO_CURRENT_CONTEXT, @ref GLFW_INVALID_VALUE and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref context_glext"]
    #[doc = "  @sa glfwGetProcAddress"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup context"]
    pub fn glfwExtensionSupported(
        extension: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the address of the specified function for the current"]
    #[doc = "  context."]
    #[doc = ""]
    #[doc = "  This function returns the address of the specified OpenGL or OpenGL ES"]
    #[doc = "  [core or extension function](@ref context_glext), if it is supported"]
    #[doc = "  by the current context."]
    #[doc = ""]
    #[doc = "  A context must be current on the calling thread.  Calling this function"]
    #[doc = "  without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error."]
    #[doc = ""]
    #[doc = "  This function does not apply to Vulkan.  If you are rendering with Vulkan,"]
    #[doc = "  see @ref glfwGetInstanceProcAddress, `vkGetInstanceProcAddr` and"]
    #[doc = "  `vkGetDeviceProcAddr` instead."]
    #[doc = ""]
    #[doc = "  @param[in] procname The ASCII encoded name of the function."]
    #[doc = "  @return The address of the function, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_NO_CURRENT_CONTEXT and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark The address of a given function is not guaranteed to be the same"]
    #[doc = "  between contexts."]
    #[doc = ""]
    #[doc = "  @remark This function may return a non-`NULL` address despite the"]
    #[doc = "  associated version or extension not being available.  Always check the"]
    #[doc = "  context version or extension string first."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned function pointer is valid until the context"]
    #[doc = "  is destroyed or the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref context_glext"]
    #[doc = "  @sa glfwExtensionSupported"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup context"]
    pub fn glfwGetProcAddress(procname: *const ::std::os::raw::c_char) -> GLFWglproc;
}
extern "C" {
    #[doc = " @brief Returns whether the Vulkan loader has been found."]
    #[doc = ""]
    #[doc = "  This function returns whether the Vulkan loader has been found.  This check"]
    #[doc = "  is performed by @ref glfwInit."]
    #[doc = ""]
    #[doc = "  The availability of a Vulkan loader does not by itself guarantee that window"]
    #[doc = "  surface creation or even device creation is possible.  Call @ref"]
    #[doc = "  glfwGetRequiredInstanceExtensions to check whether the extensions necessary"]
    #[doc = "  for Vulkan surface creation are available and @ref"]
    #[doc = "  glfwGetPhysicalDevicePresentationSupport to check whether a queue family of"]
    #[doc = "  a physical device supports image presentation."]
    #[doc = ""]
    #[doc = "  @return `GLFW_TRUE` if Vulkan is available, or `GLFW_FALSE` otherwise."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref vulkan_support"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup vulkan"]
    pub fn glfwVulkanSupported() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the Vulkan instance extensions required by GLFW."]
    #[doc = ""]
    #[doc = "  This function returns an array of names of Vulkan instance extensions required"]
    #[doc = "  by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the"]
    #[doc = "  list will always contains `VK_KHR_surface`, so if you don't require any"]
    #[doc = "  additional extensions you can pass this list directly to the"]
    #[doc = "  `VkInstanceCreateInfo` struct."]
    #[doc = ""]
    #[doc = "  If Vulkan is not available on the machine, this function returns `NULL` and"]
    #[doc = "  generates a @ref GLFW_API_UNAVAILABLE error.  Call @ref glfwVulkanSupported"]
    #[doc = "  to check whether Vulkan is available."]
    #[doc = ""]
    #[doc = "  If Vulkan is available but no set of extensions allowing window surface"]
    #[doc = "  creation was found, this function returns `NULL`.  You may still use Vulkan"]
    #[doc = "  for off-screen rendering and compute work."]
    #[doc = ""]
    #[doc = "  @param[out] count Where to store the number of extensions in the returned"]
    #[doc = "  array.  This is set to zero if an error occurred."]
    #[doc = "  @return An array of ASCII encoded extension names, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_API_UNAVAILABLE."]
    #[doc = ""]
    #[doc = "  @remarks Additional extensions may be required by future versions of GLFW."]
    #[doc = "  You should check if any extensions you wish to enable are already in the"]
    #[doc = "  returned array, as it is an error to specify an extension more than once in"]
    #[doc = "  the `VkInstanceCreateInfo` struct."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned array is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is guaranteed to be valid only until the"]
    #[doc = "  library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref vulkan_ext"]
    #[doc = "  @sa glfwCreateWindowSurface"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup vulkan"]
    pub fn glfwGetRequiredInstanceExtensions(count: *mut u32)
        -> *mut *const ::std::os::raw::c_char;
}
